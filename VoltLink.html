<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>VoltLink 5.0 - Challenge</title>

<link rel="icon" type="image/png" href="logo 2.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=JetBrains+Mono:wght@700&display=swap" rel="stylesheet">

<style>
  :root {
    --text: #1e293b;
    --glass: rgba(255, 255, 255, 0.96);
    --primary: #2563eb;
    --success: #16a34a;
    --danger: #dc2626;
    --warn: #f97316;
    --lcd-bg: #c4d4c4;
    --lcd-text: #1f2923;
  }

  body {
    margin: 0; padding: 0; height: 100vh; overflow: hidden;
    background: url('fond_lycee.jpg') no-repeat center center fixed;
    background-size: cover;
    font-family: 'Inter', sans-serif;
    user-select: none; -webkit-user-select: none;
  }
  
  body::before {
    content:""; position:absolute; inset:0; background:rgba(15,23,42,0.5); z-index:0;
  }

  #lab-container {
    position: relative; z-index: 10;
    width: 96%; max-width: 1200px; height: 94vh;
    margin: 3vh auto;
    background: var(--glass);
    border: 1px solid rgba(255,255,255,0.6);
    border-radius: 24px;
    box-shadow: 0 30px 60px -12px rgba(0,0,0,0.7);
    display: flex; gap: 20px; padding: 20px; box-sizing: border-box;
  }

  #game-viewport {
    flex: 1; position: relative;
    border-radius: 16px; overflow: hidden;
    box-shadow: inset 0 0 60px rgba(0,0,0,0.6);
    border: 2px solid #334155;
    background: linear-gradient(rgba(16, 185, 129, 0.4), rgba(5, 150, 105, 0.5)), url("image_0.png");
    background-size: cover; background-position: center;
    cursor: crosshair;
  }
  canvas { display: block; width: 100%; height: 100%; }

  /* TIMER BAR */
  #timer-bar {
    position: absolute; top: 0; left: 0; height: 6px; width: 100%;
    background: #e2e8f0; z-index: 5;
  }
  #timer-fill {
    height: 100%; width: 100%; background: var(--success);
    transition: width 1s linear, background 0.3s;
  }

  #hud-msg {
    position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.9); color: #fff; padding: 10px 24px; border-radius: 30px;
    font-size: 15px; font-weight: 800; pointer-events: none;
    opacity: 0; transition: opacity 0.3s; z-index: 20; white-space: nowrap;
    box-shadow: 0 5px 15px rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.2);
  }

  #sidebar { width: 320px; display: flex; flex-direction: column; gap: 12px; }

  .panel {
    background: white; padding: 12px 15px; border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05); border: 1px solid #e2e8f0;
  }
  
  .subtitle { font-size: 10px; text-transform: uppercase; color: #64748b; font-weight: 700; margin-bottom: 8px; }
  .stats-row { display: flex; gap: 10px; margin-top: 8px; }
  .stat { flex: 1; background: #f8fafc; padding: 6px; border-radius: 8px; text-align: center; }
  .stat-lbl { font-size: 9px; text-transform: uppercase; font-weight: 800; color: #94a3b8; }
  .stat-val { font-size: 16px; font-weight: 900; color: #0f172a; }

  /* VIES */
  #lives { display: flex; justify-content: center; gap: 5px; margin-top: 5px; }
  .life { width: 12px; height: 12px; background: #ef4444; border-radius: 50%; box-shadow: 0 2px 4px rgba(239,68,68,0.4); transition: all 0.3s; }
  .life.lost { background: #cbd5e1; box-shadow: none; transform: scale(0.8); }

  #multimeter {
    background: var(--lcd-bg);
    background-image: linear-gradient(rgba(0,0,0,0.05) 50%, transparent 50%);
    background-size: 100% 4px;
    border: 4px solid #57534e; border-radius: 8px;
    padding: 10px; font-family: 'JetBrains Mono', monospace; color: var(--lcd-text);
    transition: all 0.3s; box-shadow: inset 0 0 15px rgba(0,0,0,0.15);
  }
  #multimeter.active { border-color: var(--primary); box-shadow: 0 0 15px rgba(37, 99, 235, 0.4); }
  #multimeter.danger { border-color: var(--danger); background: #fee2e2; color: #7f1d1d; animation: shake 0.4s; }
  
  .lcd-line { display: flex; justify-content: space-between; font-size: 11px; font-weight: 800; margin-bottom: 4px; opacity: 0.85; }
  .lcd-big { font-size: 22px; font-weight: 800; text-align: right; margin-top: 6px; color:inherit; text-shadow: 0 1px 0 rgba(255,255,255,0.4); }
  .probe-hint { font-size: 10px; text-align: center; opacity: 0.7; margin-top: 8px; font-style: italic; font-weight: 600; }

  #edu-panel {
    background: #f0f9ff; border-left: 4px solid #38bdf8;
    font-size: 12px; line-height: 1.5; color: #334155;
    transition: all 0.3s; flex: 1; display: flex; flex-direction: column; justify-content: center;
  }
  #edu-title {
    font-size: 10px; font-weight: 800; text-transform: uppercase; color: #0284c7; margin-bottom: 6px;
    display: flex; align-items: center; gap: 5px;
  }
  .formula { display: inline-block; background: white; padding: 2px 6px; border-radius: 4px; border: 1px solid #bae6fd; font-family: 'JetBrains Mono', monospace; font-weight: bold; color: #0369a1; margin-top: 4px; }

  .btn {
    width: 100%; padding: 12px; border: none; border-radius: 8px;
    font-family: 'Inter', sans-serif; font-weight: 800; text-transform: uppercase; font-size: 13px;
    cursor: pointer; transition: all 0.2s; margin-bottom: 6px; display: flex; align-items: center; justify-content: center; gap: 8px;
  }
  .btn-primary { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: white; box-shadow: 0 4px 10px rgba(37, 99, 235, 0.3); }
  .btn-primary:active { transform: scale(0.98); }
  .btn-success { background: linear-gradient(135deg, #16a34a, #15803d); color: white; box-shadow: 0 4px 10px rgba(22, 163, 74, 0.3); animation: pulseBtn 2s infinite; }
  .btn-warn { background: #fff7ed; border: 1px solid #fdba74; color: #c2410c; }
  .btn-warn:hover { background: #ffedd5; }
  .btn-sec { background: white; border: 1px solid #cbd5e1; color: #475569; font-size: 11px; padding: 10px; }
  .btn-sec:hover { background: #f1f5f9; }

  @keyframes pulseBtn { 0% { box-shadow: 0 0 0 0 rgba(22, 163, 74, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(22, 163, 74, 0); } 100% { box-shadow: 0 0 0 0 rgba(22, 163, 74, 0); } }
  @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }

  .char-wrapper {
    position: fixed; bottom: 0; z-index: 100; pointer-events: none; display: flex; flex-direction: column; transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
  }
  .char-wrapper.right { right: 2%; align-items: flex-end; }
  .char-wrapper.right .char-img { transform: translateX(20%) translateY(110%); }
  .char-wrapper.right .bubble { margin-right: 40px; transform-origin: bottom right; }
  .char-wrapper.right .bubble::after { right: 60px; }
  .char-wrapper.left { left: 2%; align-items: flex-start; }
  .char-wrapper.left .char-img { transform: translateX(-20%) translateY(110%); }
  .char-wrapper.left .bubble { margin-left: 40px; transform-origin: bottom left; }
  .char-wrapper.left .bubble::after { left: 60px; right: auto; }
  .char-img { height: 50vh; max-height: 550px; width: auto; filter: drop-shadow(0 10px 30px rgba(0,0,0,0.6)); transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1); }
  .char-wrapper.visible .char-img { transform: translateX(0) translateY(10px); }
  .bubble { background: white; color: #0f172a; padding: 18px 24px; border-radius: 18px; font-size: 14px; font-weight: 700; line-height: 1.4; box-shadow: 0 10px 30px rgba(0,0,0,0.2); margin-bottom: -20px; max-width: 280px; position: relative; z-index: 101; opacity: 0; transform: scale(0.8) translateY(20px); transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1); }
  .bubble::after { content: ''; position: absolute; bottom: -10px; border: 12px solid transparent; border-top-color: white; }
  .char-wrapper.visible .bubble { opacity: 1; transform: scale(1) translateY(0); }

  @media (max-width: 900px) {
    #lab-container { flex-direction: column; width: 100%; height: 100%; margin: 0; border-radius: 0; padding: 10px; }
    #sidebar { width: 100%; flex-direction: row; flex-wrap: wrap; }
    .panel { flex: 1; padding: 10px; }
    .char-wrapper { display: none; }
  }
</style>
</head>
<body>

<div id="lab-container">
  <div id="game-viewport">
    <div id="timer-bar"><div id="timer-fill"></div></div>
    <canvas id="canvas"></canvas>
    <div id="hud-msg">Système Prêt</div>
  </div>

  <div id="sidebar">
    <div class="panel">
      <img src="logo 2.png" alt="Logo" style="height:35px; margin-bottom:5px;" onerror="this.style.display='none'">
      <div style="display:flex; justify-content:space-between; align-items:center">
        <h1 style="margin:0">VoltLink 5.0</h1>
        <div id="lives">
          <div class="life" id="life1"></div>
          <div class="life" id="life2"></div>
          <div class="life" id="life3"></div>
        </div>
      </div>
      <div class="subtitle">BTS CIEL - Challenge</div>
      <div class="stats-row">
        <div class="stat">
          <div class="stat-lbl">Niveau</div>
          <div class="stat-val" id="ui-lvl">1</div>
        </div>
        <div class="stat">
          <div class="stat-lbl">Score</div>
          <div class="stat-val" id="ui-score">0</div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="stat-lbl" style="margin-bottom:5px;">Multimètre (Mode Sonde)</div>
      <div id="multimeter">
        <div class="lcd-line"><span>V (Potentiel)</span> <span id="lcd-u">-- V</span></div>
        <div class="lcd-line"><span>I (Courant)</span> <span id="lcd-i">-- mA</span></div>
        <div style="height:2px; background:rgba(0,0,0,0.1); margin:6px 0;"></div>
        <div class="lcd-big" id="lcd-r">-- Ω</div>
        <div class="probe-hint" id="probe-hint">Utilisez la sonde pour détecter les pièges</div>
      </div>
    </div>

    <div class="panel" id="edu-panel">
      <div id="edu-title">
        <svg width="14" height="14" fill="currentColor" viewBox="0 0 20 20"><path d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>
        Assistant Labo
      </div>
      <div id="edu-content">
        Connecte la source <b>Vcc (5V)</b> à la LED. <br>
        Attention aux composants défectueux !
      </div>
    </div>

    <div style="margin-top:auto;">
      <button class="btn btn-primary" id="btn-check">TESTER LE CIRCUIT</button>
      <button class="btn btn-warn" id="btn-retry">RÉINITIALISER CE NIVEAU</button>
      <div style="display:flex; gap:10px;">
        <button class="btn btn-sec" id="btn-new">Nouveau</button>
        <button class="btn btn-sec" id="btn-sound">Son : ON</button>
      </div>
    </div>
  </div>
</div>

<div id="char-wrap" class="char-wrapper right">
  <div class="bubble" id="char-bub">Bienvenue !</div>
  <img src="proviseur.png" class="char-img" id="char-img">
</div>

<script>
/**
 * VOLTLINK 5.0 - CHALLENGE EDITION
 * - Timer (Stress)
 * - Lives System (3 Hearts)
 * - Trapped Components (0 Ohms resistors)
 * - Must probe before connect!
 */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const GRID_W = 7;
const GRID_H = 6;
const COLS = { wireOff: 'rgba(255, 255, 255, 0.7)', error: '#ef4444', hover: 'rgba(255,255,255,0.3)' };

let state = {
  grid: [], initialGridState: [],
  score: 0, level: 1, lives: 3,
  hover: {c:-1, r:-1},
  status: 'PLAY',
  path: null, flowIdx: 0, flowTimer: 0, flowResult: null,
  lastI: 0, muted: false, failReason: null, 
  confetti: [], particles: [],
  
  // Challenge vars
  timeLeft: 60, maxTime: 60, timerInterval: null
};

// AUDIO
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
  if(state.muted || audioCtx.state === 'suspended') { if(!state.muted)audioCtx.resume(); return; }
  const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
  osc.connect(gain); gain.connect(audioCtx.destination);
  const now = audioCtx.currentTime;
  if(type==='click') { osc.frequency.setValueAtTime(600, now); gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.001, now+0.1); osc.start(); osc.stop(now+0.1); }
  else if(type==='win') { osc.type='triangle'; osc.frequency.setValueAtTime(440, now); osc.frequency.linearRampToValueAtTime(880, now+0.4); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.4); osc.start(); osc.stop(now+0.4); }
  else if(type==='fail') { osc.type='sawtooth'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(50, now+0.4); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.4); osc.start(); osc.stop(now+0.4); }
}

// ENGINE
let tileSize = 0, offX = 0, offY = 0;
function resize() {
  const rect = canvas.parentElement.getBoundingClientRect(); const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr; canvas.height = rect.height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  tileSize = Math.floor(Math.min((rect.width-40)/GRID_W, (rect.height-40)/GRID_H));
  offX = (rect.width - tileSize * GRID_W) / 2; offY = (rect.height - tileSize * GRID_H) / 2;
}
function getGridPos(e) {
  const rect = canvas.getBoundingClientRect();
  const c = Math.floor((e.clientX - rect.left - offX)/tileSize);
  const r = Math.floor((e.clientY - rect.top - offY)/tileSize);
  if(c>=0 && c<GRID_W && r>=0 && r<GRID_H) return {c, r, valid:true};
  return {c:-1, r:-1, valid:false};
}

const TILE = { STR:1, COR:2, TEE:3, CRO:4, SRC:5, LED:6 };
const COMP = { NO:0, R:1, D:2 };
const MASKS = { [TILE.STR]:10, [TILE.COR]:6, [TILE.TEE]:14, [TILE.CRO]:15, [TILE.SRC]:2, [TILE.LED]:8 };

function getMask(t) {
  let m = MASKS[t.type] || 0;
  for(let i=0; i<t.rot; i++) { let n=0; if(m&1)n|=2; if(m&2)n|=4; if(m&4)n|=8; if(m&8)n|=1; m=n; }
  return m;
}

function getResistorColors(val) {
  const cols = ["#000", "#5c3a21", "#dc2626", "#ea580c", "#fbbf24", "#16a34a", "#2563eb", "#7e22ce", "#6b7280", "#fff"];
  if(val === 0) return ["#000", "#000", "#000"]; // Black Black Black (0 Ohm)
  if(val === 220) return [cols[2], cols[2], cols[1]]; 
  if(val === 330) return [cols[3], cols[3], cols[1]]; 
  if(val === 470) return [cols[4], cols[7], cols[1]]; 
  if(val === 1000) return [cols[1], cols[0], cols[2]]; 
  return [cols[1], cols[0], cols[2]]; 
}

function getVoltageColor(v) {
  let ratio = Math.max(0, Math.min(5, v)) / 5.0;
  let hue = 240 - (ratio * 190); 
  return `hsl(${hue}, 100%, 60%)`;
}

function generateSafePath() {
  let attempts = 0;
  while(attempts < 100) {
    let visited = new Set(); let y = Math.floor(GRID_H/2), x = 0;
    let path = [{x,y}]; visited.add(`${x},${y}`); let stuck = false;
    while(x < GRID_W-1) {
      let candidates = [];
      if(!visited.has(`${x+1},${y}`)) candidates.push({x:x+1, y:y});
      if(y>1 && !visited.has(`${x},${y-1}`)) candidates.push({x:x, y:y-1});
      if(y<GRID_H-2 && !visited.has(`${x},${y+1}`)) candidates.push({x:x, y:y+1});
      if(candidates.length === 0) { stuck = true; break; }
      let pick = candidates[Math.floor(Math.random()*candidates.length)];
      if(candidates.some(c => c.x > x) && Math.random()>0.4) pick = candidates.find(c => c.x > x) || pick;
      x = pick.x; y = pick.y; path.push({x,y}); visited.add(`${x},${y}`);
    }
    if(!stuck) return path; attempts++;
  }
  let fallback = []; for(let i=0; i<GRID_W; i++) fallback.push({x:i, y:Math.floor(GRID_H/2)}); return fallback;
}

function initLevel() {
  state.status = 'PLAY'; state.path = null; state.grid = []; state.failReason = null; state.confetti = []; state.particles = [];
  updateEdu("intro"); updateMultimeterUI(false); updateMainButton("check");
  
  // Timer setup based on level
  state.maxTime = Math.max(20, 60 - (state.level * 2));
  state.timeLeft = state.maxTime;
  startTimer();

  const types = [TILE.STR, TILE.COR, TILE.TEE, TILE.CRO];
  for(let y=0; y<GRID_H; y++) {
    let row = [];
    for(let x=0; x<GRID_W; x++) row.push({type:types[Math.floor(Math.random()*types.length)], rot:0, anim:0, comp:COMP.NO, val:0, potential:0, isTrap:false});
    state.grid.push(row);
  }

  let path = generateSafePath();
  let straightIndices = [];
  for(let i=1; i<path.length-1; i++) {
    let pre=path[i-1], cur=path[i], nxt=path[i+1];
    if(pre.x!==nxt.x && pre.y!==nxt.y) continue; 
    straightIndices.push(i);
  }
  let forceR = (straightIndices.length>0) ? straightIndices[Math.floor(Math.random()*straightIndices.length)] : -1;

  for(let i=0; i<path.length; i++) {
    let cur = path[i], t = state.grid[cur.y][cur.x];
    if(i===0) {
      t.type = TILE.SRC; t.fixed=true; let nxt = path[1];
      if(nxt.x > cur.x) t.rot = 0; else if(nxt.y > cur.y) t.rot = 1; else t.rot = 3;
    } 
    else if(i===path.length-1) {
      t.type = TILE.LED; t.fixed=true; let pre = path[i-1];
      if(pre.x < cur.x) t.rot = 0; else if(pre.y < cur.y) t.rot = 1; else t.rot = 3;
    } 
    else {
      let pre = path[i-1], nxt = path[i+1];
      let d1x=cur.x-pre.x, d1y=cur.y-pre.y; let d2x=nxt.x-cur.x, d2y=nxt.y-cur.y;
      if(d1x===d2x && d1y===d2y) { 
        t.type = TILE.STR; t.rot = (d1x!==0)?0:1;
        // Logic components
        if(i === forceR) {
           t.comp = COMP.R; t.val = [220,330,470,1000][Math.floor(Math.random()*4)];
        } 
        else if (Math.random()>0.5) {
           // TRAP LOGIC: Chance to spawn a bad resistor
           let isTrap = (state.level >= 2 && Math.random() < 0.2); 
           t.comp = (state.level>2 && Math.random()>0.8 && !isTrap)?COMP.D:COMP.R;
           if(t.comp===COMP.R) {
             t.val = isTrap ? 0 : [220,330,470,1000][Math.floor(Math.random()*4)];
             t.isTrap = isTrap;
           }
        }
      } else t.type = TILE.COR;
    }
  }
  state.grid.forEach(r => r.forEach(t => { if(!t.fixed) t.rot = Math.floor(Math.random()*4); t.anim = t.rot*Math.PI/2; }));
  saveInitialState(); updateUI(); showChar("intro");
}

function saveInitialState() { state.initialGridState = state.grid.map(row => row.map(t => t.rot)); }

function startTimer() {
  if(state.timerInterval) clearInterval(state.timerInterval);
  state.timerInterval = setInterval(() => {
    if(state.status === 'PLAY') {
      state.timeLeft -= 0.1;
      let pct = (state.timeLeft / state.maxTime) * 100;
      let bar = document.getElementById('timer-fill');
      bar.style.width = pct + "%";
      if(pct < 30) bar.style.background = "#ef4444";
      else if(pct < 60) bar.style.background = "#f97316";
      else bar.style.background = "#16a34a";

      if(state.timeLeft <= 0) {
        state.timeLeft = 0;
        fail("timeout");
      }
    }
  }, 100);
}

function resetLevel() {
  if(state.status === 'SUCCESS') return;
  state.status = 'PLAY'; state.path = null; state.failReason = null; state.confetti = []; state.particles = [];
  state.timeLeft = state.maxTime; // Reset time
  msg("Niveau Réinitialisé", 0); updateMultimeterUI(false); updateMainButton("check");
  for(let y=0; y<GRID_H; y++) for(let x=0; x<GRID_W; x++) {
    let t = state.grid[y][x]; t.rot = state.initialGridState[y][x]; t.anim = t.rot*Math.PI/2; t.potential = 0;
  }
  updateEdu("intro");
}

function handleMainClick() { if (state.status === 'SUCCESS') { state.level++; initLevel(); } else { check(); } }

function check() {
  if(state.status === 'SUCCESS') return;
  state.status = 'PLAY'; state.failReason = null; state.particles = [];
  let q=[], vis=new Set();
  for(let y=0; y<GRID_H; y++) for(let x=0; x<GRID_W; x++) if(state.grid[y][x].type===TILE.SRC) q.push({x,y,p:[{x,y}]});
  let success = null, maxP = [];
  while(q.length) {
    let cur = q.shift(); let k = cur.x+","+cur.y;
    if(vis.has(k)) continue; vis.add(k);
    if(cur.p.length > maxP.length) maxP = cur.p;
    let t = state.grid[cur.y][cur.x];
    if(t.type === TILE.LED) { success=cur.p; break; }
    let m = getMask(t);
    let dirs = [{dx:0,dy:-1,b:1,o:4}, {dx:1,dy:0,b:2,o:8}, {dx:0,dy:1,b:4,o:1}, {dx:-1,dy:0,b:8,o:2}];
    for(let d of dirs) if(m & d.b) {
      let nx=cur.x+d.dx, ny=cur.y+d.dy;
      if(nx>=0 && nx<GRID_W && ny>=0 && ny<GRID_H) { if(getMask(state.grid[ny][nx]) & d.o) q.push({x:nx, y:ny, p:[...cur.p, {x:nx, y:ny}]}); }
    }
  }
  if(!success) { state.path = maxP; fail("open", maxP[maxP.length-1]); } else { state.path = success; startFlowAnimation(success); }
}

function startFlowAnimation(path) {
  let R=0, D=0;
  path.forEach(p => { let t=state.grid[p.y][p.x]; if(t.comp===COMP.R)R+=t.val; if(t.comp===COMP.D)D++; });
  let Vcc=5, Vdrop=2+(D*0.7); let I = (Vcc-Vdrop)/R;
  state.lastI = I; 

  let currentV = 5.0;
  path.forEach(p => {
    let t = state.grid[p.y][p.x]; t.potential = currentV; 
    let drop = 0;
    if(t.comp === COMP.R) drop = I * t.val;
    else if(t.comp === COMP.D) drop = 0.7;
    else if(t.type === TILE.LED) drop = 2.0;
    currentV -= drop; if(currentV < 0) currentV = 0;
  });

  state.status = 'FLOW'; state.flowIdx = 0; state.flowTimer = 0; state.flowResult = { I, Vdrop, R };
}

function updateFlow() {
  if(state.status === 'FLOW') {
    state.flowTimer++;
    if(state.flowTimer > 3) { 
      state.flowTimer = 0; state.flowIdx++;
      if(state.flowIdx >= state.path.length) {
        let {I, Vdrop, R} = state.flowResult; let Vcc = 5;
        if(Vcc <= Vdrop) fail("voltage", state.path[state.path.length-1]);
        else if(R===0) fail("short", state.path[0]);
        else if(I>0.03) {
           let burnPos = state.path.find(p => state.grid[p.y][p.x].comp === COMP.R) || state.path[0];
           fail("high", burnPos);
        }
        else if(I<0.001) fail("low", state.path[state.path.length-1]);
        else win(I);
      }
    }
  }
}

function spawnConfetti() { for(let i=0; i<100; i++) state.confetti.push({x:canvas.width/2, y:canvas.height/2, vx:(Math.random()-0.5)*15, vy:(Math.random()-1)*15, c:`hsl(${Math.random()*360},100%,50%)`, life:100}); }
function spawnSmoke(pos) { for(let i=0; i<50; i++) state.particles.push({x: offX + pos.x*tileSize + tileSize/2, y: offY + pos.y*tileSize + tileSize/2, vx:(Math.random()-0.5)*2, vy:-Math.random()*3, size:Math.random()*10+5, type:'smoke', life:100}); }
function spawnSparks(pos) { for(let i=0; i<30; i++) state.particles.push({x: offX + pos.x*tileSize + tileSize/2, y: offY + pos.y*tileSize + tileSize/2, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, type:'spark', life:40}); }

function drawParticles() {
  state.confetti.forEach((p,i)=>{ p.x+=p.vx; p.y+=p.vy; p.vy+=0.5; p.life--; ctx.fillStyle=p.c; ctx.fillRect(p.x,p.y,6,6); if(p.life<=0)state.confetti.splice(i,1); });
  state.particles.forEach((p,i) => {
    p.x += p.vx; p.y += p.vy; p.life--;
    if(p.type === 'smoke') { ctx.fillStyle = `rgba(50,50,50,${p.life/100})`; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); } 
    else { ctx.fillStyle = `rgba(255, 200, 0, ${p.life/40})`; ctx.fillRect(p.x, p.y, 4, 4); }
    if(p.life<=0) state.particles.splice(i,1);
  });
}

function updateEdu(situation, data) {
  const box = document.getElementById('edu-content'); const boxP = document.getElementById('edu-panel'); const title = document.getElementById('edu-title');
  boxP.style.borderLeftColor = "#38bdf8"; boxP.style.background = "#f0f9ff"; title.innerText = "Conseil";
  if(situation === 'intro') box.innerHTML = `Connecte la source <b>Vcc (5V)</b> à la LED. <br>Utilise le multimètre pour vérifier les composants !`;
  else if (situation === 'victory_explore') { boxP.style.borderLeftColor = "#16a34a"; boxP.style.background = "#dcfce7"; title.innerText = "Succès !"; box.innerHTML = `Analyse les potentiels avec le multimètre avant de passer à la suite.`; }
  else if (situation === 'hover_res') { boxP.style.borderLeftColor = "#2563eb"; box.innerHTML = `<b>Résistance ${data.val}Ω</b><br>Tension avant : <b>${data.vIn}V</b><br>Tension après : <b>${data.vOut}V</b>`; }
  else if (situation === 'hover_trap') { boxP.style.borderLeftColor = "#dc2626"; box.innerHTML = `<b>ATTENTION !</b><br>Composant défectueux (Court-Circuit).<br>Ne pas utiliser !`; }
  else if (situation === 'hover_led') { boxP.style.borderLeftColor = "#eab308"; box.innerHTML = `<b>LED</b> (2V)<br>Courant qui traverse : <b>${data.i}</b>.`; }
  else if (situation === 'short') { boxP.style.borderLeftColor="#ef4444"; boxP.style.background="#fef2f2"; box.innerHTML = `<b>DANGER ! Court-Circuit</b>.<br>R=0Ω -> I infini.<br>Tu as utilisé une résistance défectueuse ?`; }
  else if (situation === 'open') box.innerHTML = `<b>Circuit Ouvert.</b><br>Utilise le multimètre pour trouver la coupure.`;
  else if (situation === 'high') { boxP.style.borderLeftColor="#f97316"; box.innerHTML = `<b>Surchauffe !</b> I > 30mA.<br>Résistance trop faible. Augmente R.`; }
  else if (situation === 'low') { boxP.style.borderLeftColor="#f97316"; box.innerHTML = `<b>Courant trop faible.</b> I < 1mA.<br>La LED ne brille pas. Diminue R.`; }
  else if (situation === 'voltage') box.innerHTML = `<b>Tension insuffisante.</b><br>Trop de diodes consomment la tension.`;
  else if (situation === 'timeout') { boxP.style.borderLeftColor="#ef4444"; box.innerHTML = `<b>Temps Écoulé !</b><br>Tu as été trop lent. Dépêche-toi la prochaine fois !`; }
}

function updateMultimeterUI(active, danger=false, success=false) {
  const m = document.getElementById('multimeter'); const h = document.getElementById('probe-hint');
  m.className = active ? 'active' : ''; if(danger) m.classList.add('danger'); if(success) m.classList.add('success');
  h.innerText = active ? "Sonde active (Fil Noir sur Masse)" : "Sonde inactive";
}

function fail(reason, errorPos) {
  state.status='FAIL'; state.failReason = reason; playSound('fail'); 
  loseLife();
  let map = { "open": ["Circuit coupé."], "short": ["Court-circuit !"], "high": ["Surcharge !"], "low": ["Signal faible."], "voltage": ["Tension basse."], "timeout": ["Temps écoulé !"] };
  msg(map[reason][0], 1); showChar("fail", map[reason][0]); updateEdu(reason); updateMultimeterUI(true, true);
  if(reason === 'short') spawnSparks(errorPos); if(reason === 'high' || reason === 'short') spawnSmoke(errorPos);
}

function loseLife() {
  state.lives--;
  document.getElementById(`life${state.lives+1}`).classList.add('lost');
  if(state.lives <= 0) {
    setTimeout(() => { alert("GAME OVER ! Retour au niveau 1."); location.reload(); }, 1000);
  }
}

function win(I) { 
  state.status='SUCCESS'; playSound('win'); spawnConfetti();
  state.score += 100+state.level*50 + Math.floor(state.timeLeft*10); 
  msg(`SUCCÈS : ${(I*1000).toFixed(1)} mA`, 2); 
  showChar("success"); 
  updateUI(); updateMultimeterUI(true, false, true); updateMainButton("next"); updateEdu("victory_explore");
}

function updateMainButton(mode) {
  const btn = document.getElementById('btn-check');
  if(mode === "next") { btn.innerHTML = `CIRCUIT SUIVANT <span style='font-size:16px'>➔</span>`; btn.className = "btn btn-success"; } 
  else { btn.innerHTML = "TESTER LE CIRCUIT"; btn.className = "btn btn-primary"; }
}

// RENDER
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  updateFlow();
  ctx.strokeStyle = "rgba(255,255,255,0.05)"; ctx.lineWidth=1;
  ctx.beginPath();
  for(let i=0; i<=GRID_W; i++) { ctx.moveTo(offX+i*tileSize,0); ctx.lineTo(offX+i*tileSize,canvas.height); }
  for(let i=0; i<=GRID_H; i++) { ctx.moveTo(0,offY+i*tileSize); ctx.lineTo(canvas.width,offY+i*tileSize); }
  ctx.stroke();

  for(let y=0; y<GRID_H; y++) for(let x=0; x<GRID_W; x++) drawTile(x,y);
  drawParticles();

  if(state.hover.valid && state.status!=='FLOW') {
    let hx=offX+state.hover.c*tileSize+tileSize/2, hy=offY+state.hover.r*tileSize+tileSize/2;
    ctx.shadowBlur=5; ctx.shadowColor="black"; ctx.fillStyle="#dc2626"; ctx.beginPath(); ctx.arc(hx,hy,4,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle="#b91c1c"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(hx,hy); ctx.lineTo(hx+15,hy-20); ctx.stroke();
    ctx.lineWidth=6; ctx.beginPath(); ctx.moveTo(hx+15,hy-20); ctx.lineTo(hx+25,hy-35); ctx.stroke(); ctx.shadowBlur=0;
  }
  if(state.hover.valid && state.status!=='SUCCESS') {
    let x=offX+state.hover.c*tileSize, y=offY+state.hover.r*tileSize;
    ctx.strokeStyle=COLS.hover; ctx.lineWidth=2; ctx.strokeRect(x+2,y+2,tileSize-4,tileSize-4);
  }
  requestAnimationFrame(draw);
}

function drawTile(gx, gy) {
  let t = state.grid[gy][gx];
  let x = offX + gx*tileSize + tileSize/2; let y = offY + gy*tileSize + tileSize/2;
  let trg = t.rot*Math.PI/2, diff = trg - t.anim; if(Math.abs(diff)>0.01) t.anim += diff*0.2; else t.anim = trg;

  ctx.save(); ctx.translate(x,y); ctx.rotate(t.anim);

  let c=COLS.wireOff, shadow=0, pIdx=-1;
  if(state.path) pIdx = state.path.findIndex(p=>p.x===gx && p.y===gy);
  
  if(pIdx!==-1) {
    if(state.status==='FAIL') c=COLS.error;
    else if(state.status==='SUCCESS' || (state.status === 'FLOW' && pIdx <= state.flowIdx)) {
       c = getVoltageColor(t.potential); shadow = 15;
    }
  }
  ctx.strokeStyle=c; ctx.lineWidth=tileSize*0.16; ctx.lineCap="round";
  if(shadow>0){ ctx.shadowColor=c; ctx.shadowBlur=shadow; }

  ctx.beginPath();
  if(t.type===TILE.STR){ ctx.moveTo(-tileSize*0.5,0); ctx.lineTo(tileSize*0.5,0); }
  else if(t.type===TILE.COR){ ctx.moveTo(tileSize*0.5,0); ctx.lineTo(0,0); ctx.lineTo(0,tileSize*0.5); }
  else if(t.type===TILE.TEE){ ctx.moveTo(-tileSize*0.5,0); ctx.lineTo(tileSize*0.5,0); ctx.moveTo(0,0); ctx.lineTo(0,tileSize*0.5); }
  else if(t.type===TILE.CRO){ ctx.moveTo(-tileSize*0.5,0); ctx.lineTo(tileSize*0.5,0); ctx.moveTo(0,-tileSize*0.5); ctx.lineTo(0,tileSize*0.5); }
  else if(t.type===TILE.SRC){ ctx.moveTo(0,0); ctx.lineTo(tileSize*0.4,0); }
  else if(t.type===TILE.LED){ ctx.moveTo(0,0); ctx.lineTo(-tileSize*0.4,0); }
  ctx.stroke(); ctx.shadowBlur=0;

  if(t.comp===COMP.R) {
    let w=tileSize*0.5, h=tileSize*0.22;
    ctx.fillStyle="#e2e8f0"; ctx.fillRect(-w/2,-h/2,w,h);
    let clrs = getResistorColors(t.val);
    ctx.fillStyle=clrs[0]; ctx.fillRect(-w/4, -h/2, w/8, h);
    ctx.fillStyle=clrs[1]; ctx.fillRect(-w/10, -h/2, w/8, h);
    ctx.fillStyle=clrs[2]; ctx.fillRect(w/12, -h/2, w/8, h);
    ctx.rotate(-Math.PI/2); ctx.fillStyle="white"; ctx.font="9px Arial"; ctx.textAlign="center"; 
    // Si c'est un piège, ne pas afficher 0 ohm pour tricher, afficher les bagues noires
    ctx.fillText(t.val+"Ω",0,-w/2-2);
  } else if(t.comp===COMP.D) {
    let s=tileSize*0.16; ctx.fillStyle="#cbd5e1"; ctx.beginPath(); ctx.moveTo(-s,-s); ctx.lineTo(-s,s); ctx.lineTo(s,0); ctx.fill();
    ctx.strokeStyle="#dc2626"; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(s,-s); ctx.lineTo(s,s); ctx.stroke();
  }
  ctx.restore();

  if(t.type===TILE.SRC){ ctx.fillStyle="#f59e0b"; ctx.beginPath(); ctx.arc(x,y,tileSize*0.22,0,Math.PI*2); ctx.fill(); ctx.fillStyle="white"; ctx.font="bold 10px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("5V",x,y); }
  if(t.type===TILE.LED){
    let lit = (state.status==='SUCCESS' || (state.status==='FLOW' && pIdx!==-1 && pIdx<=state.flowIdx));
    ctx.fillStyle=lit?"#fbbf24":"#475569"; if(lit){ ctx.shadowColor="#fbbf24"; ctx.shadowBlur=20; }
    ctx.beginPath(); ctx.arc(x,y,tileSize*0.2,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
  }
}

canvas.addEventListener('contextmenu', e => e.preventDefault());
canvas.addEventListener('mousedown', e => {
  let pos = getGridPos(e);
  if(pos.valid && !state.grid[pos.r][pos.c].fixed && state.status !== 'SUCCESS') {
    let t = state.grid[pos.r][pos.c];
    if(e.button === 0) t.rot = (t.rot+1)%4; if(e.button === 2) t.rot = (t.rot+3)%4;
    playSound('click');
  }
});
canvas.addEventListener('mousemove', e => {
  let pos = getGridPos(e); state.hover = pos.valid ? pos : {c:-1, r:-1};
  let u="--", i="--", r="--";
  if(pos.valid) {
    let t = state.grid[pos.r][pos.c];
    
    // Si on joue, on montre la valeur du composant pour détecter les pièges
    if(state.status === 'PLAY' && t.comp === COMP.R) {
        r = t.val + " Ω";
        if(t.isTrap) {
            updateEdu("hover_trap");
            u = "DANGER"; i = "DANGER";
        } else {
            u = "--"; i = "--";
        }
    }
    else if((state.status==='SUCCESS' || state.status==='FAIL')) {
      // Logic post-game
      let inPath = state.path && state.path.some(p => p.x===pos.c && p.y===pos.r);
      if(state.status === 'SUCCESS' && inPath) {
         if(t.comp === COMP.R) {
           let vDrop = (state.lastI*t.val);
           updateEdu("hover_res", {val:t.val, vIn:t.potential.toFixed(2), vOut:(t.potential-vDrop).toFixed(2)});
         }
         else if(t.type === TILE.LED) updateEdu("hover_led", {i:(state.lastI*1000).toFixed(1)+"mA"});
      }
      if(inPath) {
        if(state.failReason === 'short' || state.failReason === 'high') { i="⚠️"; u="⚠️"; r = (t.comp===COMP.R)?t.val+" Ω":"0 Ω"; } 
        else if (state.failReason === 'open') { i="0.0 mA"; u=(t.type===TILE.SRC)?"5.00 V":"0.00 V"; if(t.comp===COMP.R)r=t.val+" Ω"; }
        else { 
          i=(state.lastI*1000).toFixed(1)+" mA"; 
          if(t.comp===COMP.R){ u=t.potential.toFixed(2)+" V"; r=t.val+" Ω"; } 
          else if(t.type===TILE.SRC){ u="5.00 V"; r="Source"; } 
          else if(t.type===TILE.LED){ u="2.00 V"; r="LED"; } 
          else { u=t.potential.toFixed(2)+" V"; r="Fil"; } 
        }
      } else { u="0.00 V"; i="0.0 mA"; r="∞"; }
    }
  }
  document.getElementById('lcd-u').innerText = u; document.getElementById('lcd-i').innerText = i; document.getElementById('lcd-r').innerText = r;
});

function updateUI() { document.getElementById('ui-lvl').innerText = state.level; document.getElementById('ui-score').innerText = state.score; }
function msg(txt, type) { let h = document.getElementById('hud-msg'); h.innerText = txt; h.style.opacity = 1; h.style.background = (type===1)?"rgba(220,38,38,0.9)":"rgba(22,163,74,0.9)"; }
function showChar(type, txt) {
  let wrap = document.getElementById('char-wrap'); let img = document.getElementById('char-img'); let bub = document.getElementById('char-bub');
  let msgs = { intro: ["Connecte Vcc à la LED !", "N'oublie pas la résistance."], success: ["Excellent !", "C'est parfait.", "Tu gères !"], fail: ["Court-circuit !", "Ça ne marche pas.", "Recommence."] };
  let isProf = (Math.random() > 0.5); 
  wrap.classList.remove('left', 'right', 'visible');
  if(isProf) { wrap.classList.add('left'); let id = 1 + Math.floor(Math.random()*7); img.src = `Perso${id}.png`; } else { wrap.classList.add('right'); img.src = "proviseur.png"; }
  void wrap.offsetWidth; bub.innerText = txt || msgs[type][Math.floor(Math.random()*msgs[type].length)];
  wrap.classList.add('visible'); setTimeout(() => wrap.classList.remove('visible'), 5000);
}

document.getElementById('btn-check').addEventListener('click', handleMainClick);
document.getElementById('btn-retry').addEventListener('click', resetLevel);
document.getElementById('btn-new').addEventListener('click', () => { state.level++; initLevel(); });
document.getElementById('btn-sound').addEventListener('click', function(){state.muted=!state.muted;this.innerText=state.muted?"Son : OFF":"Son : ON";});

window.addEventListener('resize', resize);
resize(); initLevel(); draw();

</script>
</body>
</html>