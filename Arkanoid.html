<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Arkanoid BTS CIEL - Lyc√©e Simone Veil</title>

<link rel="icon" type="image/jpeg" href="logo 2.png">

<style>
  html, body {
    height: 100%; margin: 0; padding: 0; overflow: hidden; overscroll-behavior: none;
  }
  body {
    background: url("fond_lycee.jpg") no-repeat center center fixed;
    background-color: #2c3e50; background-size: cover; color: #000;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    display: flex; justify-content: center; align-items: center; position: relative;
  }
  #main {
    background: rgba(255, 255, 255, 0.65); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    border-radius: 16px; padding: 10px; display: flex; flex-direction: column; align-items: center;
    gap: 5px; box-sizing: border-box; box-shadow: 0 20px 50px rgba(0,0,0,0.5), inset 0 0 0 1px rgba(255,255,255,0.5);
    width: 98%; height: 98%; max-width: 1000px; justify-content: center; position: relative; z-index: 5;
  }

  @keyframes shake {
    10%, 90% { transform: translate3d(-1px, 0, 0); }
    20%, 80% { transform: translate3d(2px, 0, 0); }
    30%, 50%, 70% { transform: translate3d(-3px, 0, 0); }
    40%, 60% { transform: translate3d(3px, 0, 0); }
  }
  .shake-effect { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }

  @keyframes microShake {
    0% { transform: translate3d(0, 0, 0); }
    25% { transform: translate3d(2px, 2px, 0); }
    50% { transform: translate3d(-2px, -2px, 0); }
    75% { transform: translate3d(1px, -1px, 0); }
    100% { transform: translate3d(0, 0, 0); }
  }
  .micro-shake { animation: microShake 0.15s linear; }

  #flash-overlay {
    position: absolute; top:0; left:0; width:100%; height:100%;
    background: white; opacity: 0; pointer-events: none; z-index: 20;
    transition: opacity 0.1s ease-out;
  }

  #header-group { text-align: center; margin-bottom: 5px; }
  #logo { width: 60px; height: auto; display: block; margin: 0 auto; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2)); }
  #title { font-size: 20px; font-weight: 900; color: #222; margin: 0; letter-spacing: -0.5px; text-shadow: 0 1px 0 rgba(255,255,255,0.8); }
  #subtitle { font-size: 11px; color: #444; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
  #game-container {
    display: flex; gap: 20px; align-items: flex-start; justify-content: center;
    height: 75vh; width: 100%; position: relative;
  }
  #pause-overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(44, 62, 80, 0.85); backdrop-filter: blur(4px);
    display: none; flex-direction: column; justify-content: center; align-items: center;
    z-index: 50; color: white; font-weight: 900; font-size: 40px;
    text-shadow: 0 4px 10px rgba(0,0,0,0.5); border-radius: 4px; pointer-events: none; 
    opacity: 0; transition: opacity 0.2s ease;
  }
  #pause-overlay.visible { opacity: 1; pointer-events: auto; }
  #pause-overlay span { font-size: 14px; font-weight: normal; margin-top: 10px; opacity: 0.8; letter-spacing: 1px; }
  canvas#arkanoid {
    border: 4px solid #34495e; background: transparent; display: block;
    box-shadow: inset 0 0 30px rgba(0,0,0,0.2), 0 10px 20px rgba(0,0,0,0.3);
    height: 100%; width: auto; aspect-ratio: 3/4; border-radius: 6px;
    position: relative; z-index: 5; image-rendering: auto; touch-action: none; cursor: none; 
  }
  #side-panel {
    display: flex; flex-direction: column; gap: 10px;
    background: rgba(255,255,255,0.8); padding: 15px; border-radius: 12px;
    min-width: 180px; border: 1px solid rgba(0,0,0,0.1); box-sizing: border-box;
    height: 100%; justify-content: flex-start; box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    overflow-y: auto; 
  }
  #score-box, #level-box, #lives-box {
    text-align: center; margin-bottom: 5px; 
    background: linear-gradient(145deg, #ffffff, #f0f0f0);
    padding: 8px; border-radius: 8px; border: 1px solid rgba(0,0,0,0.05);
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
  }
  #lives-count { font-size: 24px; font-weight: 900; color: #e74c3c; }
  .label-text { font-size: 10px; text-transform: uppercase; color: #7f8c8d; font-weight: 800; letter-spacing: 1px; }
  #score { font-size: 24px; font-weight: 900; color: #2c3e50; font-variant-numeric: tabular-nums; letter-spacing: -1px; }
  #level { font-size: 20px; font-weight: bold; color: #e67e22; }
  #rank-name { font-size: 11px; font-weight: 800; color: #c0392b; margin-top: 2px; min-height: 20px; line-height: 1.2; text-transform: uppercase;}
  #highscore-title { font-size: 12px; font-weight: bold; margin-top: 10px; text-decoration: none; text-transform: uppercase; color: #333; border-bottom: 2px solid #ddd; padding-bottom: 2px; }
  #highscore-list { padding-left: 0; list-style: none; margin: 10px 0; font-size: 12px; max-height: 150px; overflow-y: auto; font-family: 'Courier New', monospace; }
  #highscore-list li { margin-bottom: 4px; padding: 2px 5px; background: rgba(0,0,0,0.03); border-radius: 4px; display: flex; justify-content: space-between; }
  #highscore-list li:first-child { font-weight: bold; background: #fff3cd; color: #856404; }
  button {
    padding: 12px; border-radius: 8px; border: none; background: #34495e; color: white;
    font-weight: bold; font-size: 12px; cursor: pointer; transition: all 0.2s;
    margin-top: 5px; box-shadow: 0 4px 0 #2c3e50; text-transform: uppercase; letter-spacing: 0.5px;
  }
  button:hover { background: #415b76; transform: translateY(-1px); box-shadow: 0 5px 0 #2c3e50; }
  button:active { transform: translateY(3px); box-shadow: 0 1px 0 #2c3e50; }
  button:focus { outline: none; }
  #controls-info { font-size: 10px; line-height: 1.5; margin-top: auto; color: #555; background: rgba(0,0,0,0.03); padding: 8px; border-radius: 6px; border: 1px dashed #bbb; }
  #message-center {
    font-size: 20px; font-weight: 900; text-align: center; color: #e74c3c;
    min-height: 24px; margin-top: 8px; 
    text-shadow: 2px 2px 0px rgba(255,255,255,1), 0 0 10px rgba(231, 76, 60, 0.3);
    animation: pulse 1.5s infinite;
  }
  @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }
  #mobile-controls { display: none; width: 100%; justify-content: center; margin-top: 5px; gap: 20px; padding-bottom: 5px; touch-action: none; z-index: 100; position: relative; }
  .pad-group { display: flex; gap: 12px; }
  .mob-btn {
    width: 65px; height: 65px; font-size: 24px; display: flex; justify-content: center; align-items: center;
    background: linear-gradient(145deg, #ffffff, #e6e6e6); border: 2px solid #ccc; border-radius: 50%;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1); touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent;
    color: #333;
  }
  .mob-btn:active { transform: translateY(4px); box-shadow: none; background: #ddd; }
  .mob-btn.big { width: 75px; height: 75px; background: linear-gradient(145deg, #f1c40f, #f39c12); color: white; border: 2px solid #d35400; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
  @keyframes popIn { from { transform: scale(0) translateY(100px); opacity: 0; } to { transform: scale(1) translateY(0); opacity: 1; } }
  #proviseur-box, #prof-box { position: fixed; bottom: 0; display: none; cursor: pointer; z-index: 100; transition: transform 0.3s ease-out; }
  #proviseur-box { right: 2%; left: auto; } 
  #prof-box { left: 2%; right: auto; } 
  #proviseur-box.game-over-proviseur { z-index: 200; bottom: 5%; right: 15%; transform: scale(1.2); }
  #proviseur-box.pop-in, #prof-box.pop-in { animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
  #proviseur-img, #prof-img { height: auto; max-height: 45vh; filter: drop-shadow(0 10px 20px rgba(0,0,0,0.4)); image-rendering: -webkit-optimize-contrast; position: relative; z-index: 1; }
  #speech-bubble, #prof-bubble {
    position: absolute; bottom: calc(100% + 10px); background: #ffffff; border: 3px solid #2c3e50; 
    border-radius: 18px; padding: 15px 20px; font-size: 15px; line-height: 1.4; font-weight: 700; color: #2c3e50;
    box-shadow: 0 10px 25px rgba(0,0,0,0.2); cursor: pointer; min-width: 250px; max-width: 350px; 
    opacity: 0; animation: fadeIn 0.3s 0.2s forwards; z-index: 2; 
  }
  @keyframes fadeIn { to { opacity: 1; } }
  #speech-bubble::after, #prof-bubble::after {
      content: ''; position: absolute; width: 0; height: 0; border-style: solid; border-width: 12px;
      top: 100%; border-color: #2c3e50 transparent transparent transparent; z-index: 3;
      filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1));
  }
  #speech-bubble { right: 50%; text-align: right; transform: translateX(50%); }
  #speech-bubble::after { right: 40px; }
  #prof-bubble { left: 50%; text-align: left; transform: translateX(-50%); }
  #prof-bubble::after { left: 40px; }
  @media (max-width: 900px) {
    #main { width: 100%; height: 100%; padding: 5px; border-radius: 0; justify-content: space-between; }
    #header-group { display: none; }
    #game-container { height: 60vh; align-items: center; width: 100%; gap: 5px; }
    #side-panel { display: none; } 
    #mobile-header { display: flex; flex-direction: column; align-items: center; width: 95%; font-weight: bold; font-size: 14px; margin-top: 5px; background: rgba(255,255,255,0.8); padding: 5px; border-radius: 8px; border: 1px solid rgba(0,0,0,0.1); }
    #mobile-header-row { display: flex; justify-content: space-between; width: 100%; }
    #mob-rank { color: #d32f2f; font-size: 12px; margin-top: 2px; font-weight: 900;}
    #mobile-controls { display: flex; padding: 0 10px 20px 10px; box-sizing: border-box; flex-wrap: wrap; justify-content: center; }
    #message-center { font-size: 14px; margin-bottom: 5px; }
    #proviseur-box, #prof-box { display: none !important; }
  }
  @media (min-width: 901px) { #mobile-header { display: none; } }
</style>
</head>
<body>

<div id="main">

  <div id="header-group">
    <img id="logo" src="Logo.gif" alt="Logo BTS" onerror="this.style.display='none'"> 
    <div id="title">ARKANOID ‚Äì BTS CIEL</div>
    <div id="subtitle">Lyc√©e Simone Veil - Noisiel</div>
  </div>

  <div id="mobile-header">
    <div id="mobile-header-row">
        <span id="mob-score">Score: 0</span>
        <span id="mob-level">Niv: 1</span>
        <span id="mob-lives">Vies: 3</span> 
    </div>
    <div id="mob-rank">Nouvelle Recrue</div>
  </div>

  <div id="game-container">
    <canvas id="arkanoid"></canvas>
    <div id="flash-overlay"></div>
    
    <div id="pause-overlay">
        PAUSE
        <span>Appuyez sur P pour reprendre</span>
    </div>

    <div id="side-panel">
      <div id="score-box">
        <div class="label-text">Score</div>
        <div id="score">0</div>
      </div>

      <div id="level-box">
        <div class="label-text">Niveau</div>
        <div id="level">1</div>
        <div id="rank-name">Nouvelle Recrue</div>
      </div>
      
      <div id="lives-box">
        <div class="label-text">Vies</div>
        <div id="lives-count">3</div>
      </div>

      <div id="highscore-title">Meilleurs scores</div>
      <ul id="highscore-list"></ul>

      <button id="start-btn">Recommencer</button>
      <button id="mute-btn">Son : ON</button>

      <div id="controls-info">
        <b>Contr√¥les :</b><br>
        SOURIS / Tactile : Bouger<br>
        Clic / Espace : Lancer / Tirer<br>
        P : Pause
      </div>
    </div>
  </div>

  <div id="mobile-controls">
    <div class="pad-group">
      <button class="mob-btn" id="btn-left">‚óÄ</button>
      <button class="mob-btn" id="btn-right">‚ñ∂</button>
    </div>
    <div class="pad-group">
      <button class="mob-btn big" id="btn-launch">LANCER</button>
    </div>
  </div>

  <div id="message-center"></div> 
</div>

<div id="proviseur-box">
  <div id="speech-bubble"></div>
  <img id="proviseur-img" src="proviseur.png" alt="Proviseur">
</div>

<div id="prof-box">
  <div id="prof-bubble"></div>
  <img id="prof-img" src="Perso1.png" alt="Professeur">
</div>

<audio id="bg-music" loop>
    <source src="musique.mp3" type="audio/mpeg">
</audio>

<script>
  /* --- INITIALISATION OPTIMIS√âE HD --- */
  const canvas = document.getElementById("arkanoid");
  const ctx = canvas.getContext("2d", { willReadFrequently: true }); 
  const gameContainer = document.getElementById("game-container");
  const flashOverlay = document.getElementById("flash-overlay");

  const GAME_WIDTH = 600;
  const GAME_HEIGHT = 800;
  let animationId = null; 
  let gridOffset = 0; 

  function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = GAME_WIDTH * dpr;
      canvas.height = GAME_HEIGHT * dpr;
      ctx.scale(dpr, dpr);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
  }

  window.addEventListener('resize', resizeCanvas);
  setTimeout(resizeCanvas, 100);

  /* --- UI ELEMENTS --- */
  const scoreElem = document.getElementById("score");
  const levelElem = document.getElementById("level");
  const rankElem = document.getElementById("rank-name");
  const livesCountElem = document.getElementById("lives-count"); 
  const pauseOverlay = document.getElementById("pause-overlay");
  const mobScoreElem = document.getElementById("mob-score");
  const mobLevelElem = document.getElementById("mob-level");
  const mobRankElem = document.getElementById("mob-rank");
  const mobLivesElem = document.getElementById("mob-lives"); 
  const messageCenter = document.getElementById("message-center");
  const startBtn = document.getElementById("start-btn");
  const muteBtn = document.getElementById("mute-btn");
  const highscoreList = document.getElementById("highscore-list");
  const bgMusic = document.getElementById("bg-music");

  /* --- AUDIO --- */
  let muted = false;
  let audioCtx = null;
  const cielRanks = ["Nouvelle Recrue", "Apprenti C√¢bleur", "Scripteur Bash", "D√©codeur Binaire", "Admin R√©seau", "D√©veloppeur C++", "Expert Cybers√©cu", "Major de Promo"];

  function initAudioContext() {
    if (!audioCtx) { 
        const AC = window.AudioContext || window.webkitAudioContext; 
        if (AC) audioCtx = new AC(); 
    }
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(e => {});
    if (!muted && bgMusic) bgMusic.play().catch(e => {}); 
  }

  const synth = {
      playTone: (freq, type, duration, vol = 0.1) => {
          if (!audioCtx || muted) return;
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
          gain.gain.setValueAtTime(vol, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.start();
          osc.stop(audioCtx.currentTime + duration);
      },
      noise: (duration) => {
          if (!audioCtx || muted) return;
          const bufferSize = audioCtx.sampleRate * duration;
          const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
          const noise = audioCtx.createBufferSource();
          noise.buffer = buffer;
          const gain = audioCtx.createGain();
          gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
          noise.connect(gain);
          gain.connect(audioCtx.destination);
          noise.start();
      }
  };

  function sStart() { synth.playTone(600, 'square', 0.1); setTimeout(() => synth.playTone(800, 'square', 0.2), 100); }
  function sHit() { synth.playTone(300, 'sine', 0.05, 0.2); }
  function sBrick(pitchMultiplier = 1) { 
      const freq = (400 + Math.random()*200) * pitchMultiplier;
      synth.playTone(freq, 'triangle', 0.08, 0.15); 
  }
  function sPowerup() { synth.playTone(1000, 'sine', 0.1); setTimeout(() => synth.playTone(1500, 'sine', 0.2), 100); }
  function sCrack() { synth.playTone(800, 'sawtooth', 0.05, 0.1); setTimeout(() => synth.noise(0.05), 0); }
  function sShoot() { synth.playTone(800, 'sawtooth', 0.05, 0.05); } 
  function sDie() { synth.playTone(200, 'sawtooth', 0.3); setTimeout(() => synth.noise(0.3), 100); }

  muteBtn.addEventListener("click", () => {
    muted = !muted;
    muteBtn.textContent = muted ? "Son : OFF" : "Son : ON";
    if (muted) bgMusic.pause(); else { initAudioContext(); bgMusic.play().catch(()=>{}); }
  });
  
  function updateUI() {
      scoreElem.textContent = score;
      mobScoreElem.textContent = "Score: " + score;
      levelElem.textContent = level;
      mobLevelElem.textContent = "Niv: " + level;
      livesCountElem.textContent = lives; 
      mobLivesElem.textContent = "Vies: " + lives; 

      const rank = cielRanks[Math.min(level-1, cielRanks.length-1)];
      rankElem.textContent = rank;
      mobRankElem.textContent = rank;
  }
  
  function getHighScores() {
      const stored = localStorage.getItem("arkanoid_highscores_ciel");
      return stored ? JSON.parse(stored) : [];
  }
  
  function checkAndSaveHighscore(finalScore) {
      let scores = getHighScores();
      const lowestScore = scores.length < 5 ? 0 : scores[scores.length - 1].score;
      if (finalScore > lowestScore || scores.length < 5) {
          setTimeout(() => {
              let name = prompt("NOUVEAU RECORD ! Entrez votre pseudo :", "Joueur");
              if (!name) name = "Anonyme"; 
              const date = new Date().toLocaleDateString('fr-FR', {day:'2-digit', month:'2-digit', year:'numeric'});
              scores.push({ name: name, score: finalScore, date: date });
              scores.sort((a, b) => b.score - a.score);
              scores = scores.slice(0, 5); 
              localStorage.setItem("arkanoid_highscores_ciel", JSON.stringify(scores));
              updateHighScores();
          }, 300);
      }
  }
  
  function updateHighScores() {
      const scores = getHighScores();
      highscoreList.innerHTML = scores.map((s, i) => 
          `<li ${i === 0 ? 'style="font-weight: bold; color: #c0392b;"' : ''}>
            <span>${i + 1}. ${s.name}</span>
            <span>${s.score} (${s.date})</span>
           </li>`
      ).join('');
      if (scores.length === 0) highscoreList.innerHTML = "<li>Pas encore de score.</li>";
  }

  /* --- PERSONNAGES --- */
  const proviseurBox = document.getElementById("proviseur-box");
  const profBox = document.getElementById("prof-box");
  const speechBubble = document.getElementById("speech-bubble");
  const profBubble = document.getElementById("prof-bubble");
  const profImg = document.getElementById("prof-img");

  const PROF_CONFIGS = [];
  for (let i = 1; i <= 7; i++) PROF_CONFIGS.push({ name: `Prof ${i}`, filename: `Perso${i}.png` });

  const CHAR_MESSAGES = {
      intro: {
          proviseur: ["Bienvenue en BTS CIEL. L'infrastructure num√©rique repose sur vous.", "L'excellence est notre objectif. Concentrez-vous."],
          teachers: ["Pr√™t √† relever le d√©fi ? Utilisez la raquette comme un oscillateur !", "Initialisation des protocoles... C'est parti !"]
      },
      levelUp: {
          proviseur: ["F√©licitations ! Une ascension prometteuse.", "L'√©tablissement est fier de votre performance."],
          teachers: ["Bien jou√©. Analysez le nouveau pattern.", "Le niveau de difficult√© augmente. D√©buguez votre strat√©gie."]
      },
      lifeLost: {
          proviseur: ["Une petite erreur de param√©trage. Redressez la barre.", "La tol√©rance d'erreur est limit√©e."],
          teachers: ["Erreur de trajectoire. La prochaine sera la bonne.", "Reprenez votre souffle. Vous avez encore des ressources."]
      },
      gameOver: {
          proviseur: ["Dommage. L'√©chec fait partie de l'apprentissage.", "Analysez les causes de la panne et relancez le syst√®me."],
          teachers: ["Erreur de trajectoire critique. Revoyez votre algorithme.", "Collision fatale. SegFault d√©tect√©."]
      },
      inGame: {
          proviseur: ["Gardez la cadence ! Nous vous observons.", "Rigueur et rapidit√©. Continuez."],
          teachers: ["Concentration maximale !", "Optimisez votre rebond !", "Excellent r√©flexe !"]
      }
  };

  let charTimeout = null;

  function hideCharacters() {
      clearTimeout(charTimeout); charTimeout = null; 
      proviseurBox.style.display = 'none'; profBox.style.display = 'none';
      proviseurBox.classList.remove('game-over-proviseur', 'pop-in');
      profBox.classList.remove('pop-in');
  }

  function showCharacterMessage(type, characterType) { 
      hideCharacters();
      let box, bubble, messagePool;
      if (characterType === 'proviseur') {
          box = proviseurBox; bubble = speechBubble; messagePool = CHAR_MESSAGES[type].proviseur;
      } else {
          box = profBox; bubble = profBubble;
          messagePool = CHAR_MESSAGES[type].teachers || CHAR_MESSAGES[type].lifeLost;
          const randomProf = PROF_CONFIGS[Math.floor(Math.random() * PROF_CONFIGS.length)];
          profImg.src = randomProf.filename; 
          profImg.style.filter = `drop-shadow(0 10px 20px rgba(0,0,0,0.4))`; 
      }
      const message = messagePool[Math.floor(Math.random() * messagePool.length)];
      bubble.textContent = message;
      if (type === 'gameOver' && characterType === 'proviseur') box.classList.add('game-over-proviseur');
      box.style.display = 'block'; void box.offsetWidth; box.classList.add('pop-in');
      charTimeout = setTimeout(hideCharacters, 5000); 
  }

  function triggerCharacter(type) {
      if (gameState === "paused" || gameState === "recovering" || (type === 'inGame' && charTimeout !== null)) return; 
      let charType;
      if (type === 'intro' || type === 'gameOver' || type === 'lifeLost') charType = 'proviseur'; 
      else charType = Math.random() < 0.2 ? 'proviseur' : 'teacher';
      showCharacterMessage(type, charType);
  }

  /* --- LOGIQUE ARKANOID --- */
  const FACE_COUNT = 11; 
  const tileImages = [null];
  for (let i = 1; i <= FACE_COUNT; i++) {
    const img = new Image(); img.src = "visage" + i + ".jpg"; tileImages[i] = img;
  }
  const colors = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF', '#555555'];
  
  const PADDLE_WIDTH = 100;
  const PADDLE_HEIGHT = 18;
  const BALL_RADIUS = 7;
  const BRICK_COLS = 8; 
  const BRICK_PADDING = 6;
  const BRICK_OFFSET_TOP = 80;
  const BRICK_OFFSET_LEFT = 20;
  const BRICK_WIDTH = (GAME_WIDTH - 2 * BRICK_OFFSET_LEFT - (BRICK_COLS - 1) * BRICK_PADDING) / BRICK_COLS;
  const BRICK_HEIGHT = BRICK_WIDTH; 

  const POWERUP_WIDTH = 35; 
  const POWERUP_HEIGHT = 18;
  const POWERUP_DROP_SPEED = 2.5; 
  const POWERUP_PROBABILITY = 0.12; 

  const POWERUP_TYPES = {
      PADDLE_INCREASE: { color: '#2ecc71', symbol: '‚¨Ü', effect: 'width', value: 30, duration: 8000 },
      PADDLE_DECREASE: { color: '#e74c3c', symbol: '‚¨á', effect: 'width', value: -30, duration: 8000 },
      BALL_SLOW: { color: '#3498db', symbol: 'üê¢', effect: 'speed', value: -1.5, duration: 10000 },
      BALL_FAST: { color: '#f39c12', symbol: '‚ö°', effect: 'speed', value: 1.5, duration: 5000 },
      MULTI_BALL: { color: '#9b59b6', symbol: 'M', effect: 'multiball', value: 0, duration: 0 },
      STICKY_PADDLE: { color: '#1abc9c', symbol: 'C', effect: 'sticky', value: 0, duration: 10000 },
      LASER: { color: '#e74c3c', symbol: 'T', effect: 'laser', value: 0, duration: 8000 },
  };
  const POWERUP_KEYS = Object.keys(POWERUP_TYPES);
  
  let powerups = [];
  let bullets = []; 
  let activePowerup = null; 
  let defaultPaddleWidth = PADDLE_WIDTH;
  let defaultBallSpeed = 6; 

  let gameState = "waiting"; 
  let score = 0;
  let level = 1;
  let lives = 3; 
  let ballSpeed = 6;
  let inGameTriggerCounter = 0;
  const IN_GAME_CHECK_INTERVAL = 90; 
  const IN_GAME_PROBABILITY = 0.25; 
  
  let comboCount = 0;

  const paddle = { 
      x: GAME_WIDTH/2 - PADDLE_WIDTH/2, y: GAME_HEIGHT - 60, 
      width: PADDLE_WIDTH, height: PADDLE_HEIGHT, dx: 0,
      sticky: false, laser: false
  };

  let balls = [];

  function createBall(x, y, vx, vy, onPaddle = false) {
      return { x: x, y: y, radius: BALL_RADIUS, vx: vx, vy: vy, onPaddle: onPaddle, trail: [], stuckOffset: 0 };
  }

  let bricks = [];
  let particles = []; 
  let floatingTexts = [];
  let shockwaves = []; 

  function spawnFloatingText(x, y, text, color="#2ecc71") {
      floatingTexts.push({ x: x, y: y, text: text, color: color, life: 1.0, dy: -1.5 });
  }
  
  function spawnShockwave(x, y) {
      shockwaves.push({ x: x, y: y, radius: 1, alpha: 0.8 });
  }
  
  function triggerFlash() {
      flashOverlay.style.opacity = "0.4";
      setTimeout(() => flashOverlay.style.opacity = "0", 50);
  }

  const levelPatterns = [
    [[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]],
    [[1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]],
    [[1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]],
    [[1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0]],
    [[0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1]]
  ];

  function initBricks() {
      bricks = [];
      const patternIndex = (level - 1) % levelPatterns.length;
      const pattern = levelPatterns[patternIndex];
      for(let c=0; c<BRICK_COLS; c++) bricks[c] = [];
      
      const rows = pattern.length;
      for(let r=0; r<rows; r++) { 
          for(let c=0; c<BRICK_COLS; c++) { 
              if (pattern[r][c] === 1) {
                  const imgIndex = (c + r * 2) % FACE_COUNT + 1;
                  
                  // --- PROGRESSION DE LA DIFFICULT√â ---
                  let solidChance = 0;
                  if (level > 1) { // Niveau 1 : 0% de briques solides
                      solidChance = 0.10 + (level * 0.02); // Commence √† 12% et augmente doucement
                  }
                  if (solidChance > 0.4) solidChance = 0.4; // Cap √† 40%

                  const hp = Math.random() < solidChance ? 2 : 1;
                  bricks[c].push({ 
                      x: 0, y: 0, status: 1, 
                      hp: hp, maxHp: hp,
                      imgIndex: imgIndex, color: colors[imgIndex % colors.length] || '#888' 
                  });
              } else {
                  bricks[c].push({ x: 0, y: 0, status: 0, hp: 0, maxHp:0, imgIndex: 0, color: '#000' }); 
              }
          }
      }
  }

  function spawnParticles(x, y, color) {
      for(let i=0; i<10; i++) {
          particles.push({
              x: x, y: y,
              vx: (Math.random() - 0.5) * 10, 
              vy: (Math.random() - 0.5) * 10,
              life: 1.0, color: color,
              gravity: 0.15 
          });
      }
  }

  function triggerMicroShake() {
      gameContainer.classList.remove("micro-shake");
      void gameContainer.offsetWidth; 
      gameContainer.classList.add("micro-shake");
      setTimeout(() => gameContainer.classList.remove("micro-shake"), 150);
  }

  function drawBackgroundEffect() {
      ctx.strokeStyle = "rgba(44, 62, 80, 0.15)"; 
      ctx.lineWidth = 1;
      gridOffset = (gridOffset + 0.5) % 40; 
      for (let y = gridOffset; y < GAME_HEIGHT; y += 40) {
          ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(GAME_WIDTH, y); ctx.stroke();
      }
      for (let x = 0; x < GAME_WIDTH; x += 40) {
          ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, GAME_HEIGHT); ctx.stroke();
      }
  }

  function drawSpaceship(p) {
      const x = p.x;
      const y = p.y;
      const w = p.width;
      const h = p.height;
      const midX = x + w / 2;
      const noseY = y;
      const rearY = y + h;
      
      const engineFlicker = Math.random() * 0.3 + 0.7;
      const energyColor = p.laser ? "#e74c3c" : (p.sticky ? "#2ecc71" : "#3498db");

      ctx.beginPath();
      ctx.moveTo(midX, noseY); ctx.lineTo(x + w, rearY - 2); ctx.lineTo(midX + w * 0.2, rearY); ctx.lineTo(midX, rearY + 5); 
      ctx.lineTo(midX - w * 0.2, rearY); ctx.lineTo(x, rearY - 2); ctx.closePath();
      
      const bodyGrad = ctx.createLinearGradient(x, y, x + w, y + h);
      bodyGrad.addColorStop(0, '#2c3e50'); bodyGrad.addColorStop(0.5, '#4a69bd'); bodyGrad.addColorStop(1, '#2c3e50');
      ctx.fillStyle = bodyGrad; ctx.fill();
      ctx.lineWidth = 1; ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.stroke();

      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.beginPath(); ctx.moveTo(x + 5, rearY - 2); ctx.lineTo(x + w * 0.3, y + h * 0.4); ctx.lineTo(x + w * 0.3, rearY); ctx.fill();
      ctx.beginPath(); ctx.moveTo(x + w - 5, rearY - 2); ctx.lineTo(x + w * 0.7, y + h * 0.4); ctx.lineTo(x + w * 0.7, rearY); ctx.fill();

      const thrusterW = w * 0.15;
      const thrusterX_L = midX - w * 0.25;
      const thrusterX_R = midX + w * 0.25 - thrusterW;
      
      ctx.globalCompositeOperation = "screen";
      ctx.fillStyle = energyColor;
      ctx.globalAlpha = 0.6 * engineFlicker;
      ctx.beginPath(); ctx.moveTo(thrusterX_L, rearY); ctx.lineTo(thrusterX_L + thrusterW/2, rearY + 15 * engineFlicker); ctx.lineTo(thrusterX_L + thrusterW, rearY); ctx.fill();
      ctx.beginPath(); ctx.moveTo(thrusterX_R, rearY); ctx.lineTo(thrusterX_R + thrusterW/2, rearY + 15 * engineFlicker); ctx.lineTo(thrusterX_R + thrusterW, rearY); ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.globalCompositeOperation = "source-over";

      const coreSize = h * 0.6;
      ctx.shadowBlur = 15; ctx.shadowColor = energyColor;
      const coreGrad = ctx.createRadialGradient(midX, y + h/2, 2, midX, y + h/2, coreSize);
      coreGrad.addColorStop(0, "#fff"); coreGrad.addColorStop(0.4, energyColor); coreGrad.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = coreGrad; ctx.beginPath(); ctx.arc(midX, y + h/2 + 2, coreSize/2, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;

      if (p.laser) {
          ctx.fillStyle = "#c0392b";
          ctx.fillRect(x + w*0.1, y + h*0.2, 3, h); ctx.fillRect(x + w*0.9 - 3, y + h*0.2, 3, h);
      }

      if (activePowerup) {
          const timeLeft = activePowerup.endTime - Date.now();
          if (timeLeft > 0) {
              const totalDuration = activePowerup.type.duration;
              const ratio = timeLeft / totalDuration;
              const barW = p.width * 0.8; const barH = 4; const barX = p.x + (p.width - barW) / 2; const barY = p.y + p.height + 20;
              ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(barX, barY, barW, barH);
              ctx.fillStyle = activePowerup.type.color; ctx.fillRect(barX, barY, barW * ratio, barH);
          }
      }
  }

  function drawCapsule(pu) {
      const x = pu.x; const y = pu.y; const w = POWERUP_WIDTH; const h = POWERUP_HEIGHT; const r = 9; 
      const bobbing = Math.sin(Date.now() / 200) * 2;
      const drawY = y + bobbing;

      ctx.save();
      ctx.shadowColor = pu.type.color; ctx.shadowBlur = 10;
      ctx.beginPath();
      if (ctx.roundRect) ctx.roundRect(x - w/2, drawY - h/2, w, h, r); else ctx.rect(x - w/2, drawY - h/2, w, h);
      ctx.fillStyle = pu.type.color; ctx.fill(); ctx.shadowBlur = 0; 
      ctx.strokeStyle = "#fff"; ctx.lineWidth = 1.5; ctx.stroke();
      ctx.fillStyle = "rgba(255, 255, 255, 0.4)"; ctx.beginPath(); ctx.ellipse(x, drawY - h/4, w/2.5, h/4, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = "#fff"; ctx.font = "bold 11px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 2; ctx.fillText(pu.type.symbol, x, drawY + 1);
      ctx.restore();
  }

  function drawCracks(bx, by, bw, bh) {
      ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(bx + 5, by + bh - 5);
      ctx.lineTo(bx + bw*0.3, by + bh*0.7);
      ctx.lineTo(bx + bw*0.5, by + bh*0.5);
      ctx.lineTo(bx + bw*0.2, by + bh*0.2);
      ctx.moveTo(bx + bw*0.5, by + bh*0.5);
      ctx.lineTo(bx + bw*0.8, by + bh*0.6);
      ctx.lineTo(bx + bw - 5, by + 5);
      ctx.stroke();
  }

  function draw() {
      ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
      drawBackgroundEffect();
      
      ctx.globalCompositeOperation = 'lighter';
      for (let i = particles.length - 1; i >= 0; i--) {
          let p = particles[i];
          p.x += p.vx; p.y += p.vy; 
          p.vy += p.gravity; 
          p.life -= 0.03;
          if (p.life <= 0) { particles.splice(i, 1); continue; }
          ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
          ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();
          ctx.globalAlpha = 1.0;
      }
      ctx.globalCompositeOperation = 'source-over';

      for (let i = shockwaves.length - 1; i >= 0; i--) {
          let sw = shockwaves[i];
          sw.radius += 4;
          sw.alpha -= 0.05;
          if (sw.alpha <= 0) { shockwaves.splice(i, 1); continue; }
          ctx.beginPath();
          ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(255, 255, 255, ${sw.alpha})`;
          ctx.lineWidth = 3;
          ctx.stroke();
      }

      for (let i = floatingTexts.length - 1; i >= 0; i--) {
          let ft = floatingTexts[i];
          ft.y += ft.dy; ft.life -= 0.02;
          if (ft.life <= 0) { floatingTexts.splice(i, 1); continue; }
          ctx.globalAlpha = ft.life; ctx.fillStyle = ft.color; ctx.font = "bold 14px Arial";
          ctx.shadowColor = "white"; ctx.shadowBlur = 2; ctx.fillText(ft.text, ft.x, ft.y);
          ctx.shadowBlur = 0; ctx.globalAlpha = 1.0;
      }

      drawSpaceship(paddle);

      ctx.strokeStyle = "#00f3ff"; 
      ctx.shadowBlur = 10;
      ctx.shadowColor = "#00f3ff";
      ctx.lineWidth = 2;
      balls.forEach(ball => {
          if(ball.trail.length > 1) {
              ctx.beginPath();
              ctx.moveTo(ball.trail[0].x, ball.trail[0].y);
              for(let i=1; i<ball.trail.length; i++) {
                  let jitterX = (Math.random() - 0.5) * 6;
                  let jitterY = (Math.random() - 0.5) * 6;
                  ctx.lineTo(ball.trail[i].x + jitterX, ball.trail[i].y + jitterY);
              }
              ctx.lineTo(ball.x, ball.y);
              ctx.stroke();
          }
          ctx.shadowBlur = 15; ctx.shadowColor = "#fff";
          ctx.fillStyle = "#fff"; 
          ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2); ctx.fill();
          ctx.shadowBlur = 0;
      });

      ctx.fillStyle = "#e74c3c"; ctx.shadowBlur = 5; ctx.shadowColor = "#e74c3c";
      bullets.forEach(b => { ctx.fillRect(b.x, b.y, 4, 10); });
      ctx.shadowBlur = 0;

      let activeBricks = 0;
      for(let c=0; c<BRICK_COLS; c++) {
          for(let r=0; r<bricks[c].length; r++) { 
              let b = bricks[c][r];
              if(b.status === 1) {
                  activeBricks++;
                  const bx = (c*(BRICK_WIDTH+BRICK_PADDING)) + BRICK_OFFSET_LEFT;
                  const by = (r*(BRICK_HEIGHT+BRICK_PADDING)) + BRICK_OFFSET_TOP;
                  b.x = bx; b.y = by;
                  const img = tileImages[b.imgIndex];
                  if (img && img.complete) {
                      ctx.drawImage(img, bx, by, BRICK_WIDTH, BRICK_HEIGHT);
                      
                      ctx.lineWidth = 2;
                      ctx.strokeStyle = "rgba(0,0,0,0.3)";
                      ctx.strokeRect(bx, by, BRICK_WIDTH, BRICK_HEIGHT);

                      ctx.fillStyle = "rgba(255,255,255,0.25)";
                      ctx.beginPath();
                      ctx.moveTo(bx, by + BRICK_HEIGHT); ctx.lineTo(bx, by); ctx.lineTo(bx + BRICK_WIDTH, by);
                      ctx.lineTo(bx + BRICK_WIDTH - 4, by + 4); ctx.lineTo(bx + 4, by + 4); ctx.lineTo(bx + 4, by + BRICK_HEIGHT - 4);
                      ctx.closePath(); ctx.fill();

                      ctx.fillStyle = "rgba(0,0,0,0.25)";
                      ctx.beginPath();
                      ctx.moveTo(bx, by + BRICK_HEIGHT); ctx.lineTo(bx + BRICK_WIDTH, by + BRICK_HEIGHT); ctx.lineTo(bx + BRICK_WIDTH, by);
                      ctx.lineTo(bx + BRICK_WIDTH - 4, by + 4); ctx.lineTo(bx + BRICK_WIDTH - 4, by + BRICK_HEIGHT - 4); ctx.lineTo(bx + 4, by + BRICK_HEIGHT - 4);
                      ctx.closePath(); ctx.fill();
                      
                      const glass = ctx.createLinearGradient(bx, by, bx+BRICK_WIDTH, by+BRICK_HEIGHT);
                      glass.addColorStop(0, "rgba(255,255,255,0.3)"); glass.addColorStop(0.5, "rgba(255,255,255,0)"); glass.addColorStop(1, "rgba(0,0,0,0.1)");
                      ctx.fillStyle = glass; ctx.fillRect(bx+2, by+2, BRICK_WIDTH-4, BRICK_HEIGHT-4);

                      // --- NOUVEAU DESIGN BLINDAGE (SANS JAUNE) ---
                      if (b.hp === 2) {
                          // Effet verre renforc√© (Double Vitrage / Cadre Argent√© Interne)
                          ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; // Blanc translucide
                          ctx.lineWidth = 2;
                          // Petit cadre int√©rieur
                          ctx.strokeRect(bx + 5, by + 5, BRICK_WIDTH - 10, BRICK_HEIGHT - 10);
                          
                          // Reflet m√©tallique en diagonale
                          ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
                          ctx.beginPath();
                          ctx.moveTo(bx, by + BRICK_HEIGHT);
                          ctx.lineTo(bx + BRICK_WIDTH, by);
                          ctx.lineTo(bx + BRICK_WIDTH, by + 10);
                          ctx.lineTo(bx + 10, by + BRICK_HEIGHT);
                          ctx.fill();
                      } 
                      // --- SI FISSUR√â (1 PV mais MaxHP √©tait 2) ---
                      else if (b.maxHp === 2 && b.hp === 1) {
                          drawCracks(bx, by, BRICK_WIDTH, BRICK_HEIGHT);
                      }

                  } else {
                      ctx.fillStyle = b.color; ctx.fillRect(bx, by, BRICK_WIDTH, BRICK_HEIGHT);
                  }
                  
              }
          }
      }
      if (activeBricks === 0 && (gameState === "playing" || gameState === "waiting" || gameState === "recovering")) levelUp();
      
      for (let pu of powerups) { drawCapsule(pu); }
  }

  function applyPowerupEffect(puType) {
      sPowerup();
      if (puType.effect === 'multiball') {
          if (balls.length > 0) {
              const b = balls[0];
              balls.push(createBall(b.x, b.y, b.vx * 1.2, b.vy * 0.8));
              balls.push(createBall(b.x, b.y, -b.vx * 1.2, b.vy * 0.9));
              messageCenter.textContent = "MULTI-BALLES !!!";
          }
          return; 
      }

      if (activePowerup && activePowerup.timer) {
          clearTimeout(activePowerup.timer);
          resetPowerupEffects();
      }

      if (puType.effect === 'width') paddle.width += puType.value;
      if (puType.effect === 'speed') ballSpeed += puType.value;
      if (puType.effect === 'sticky') paddle.sticky = true;
      if (puType.effect === 'laser') paddle.laser = true;

      if (paddle.width < 50) paddle.width = 50; if (paddle.width > 200) paddle.width = 200; 
      if (ballSpeed < 4) ballSpeed = 4; if (ballSpeed > 10) ballSpeed = 10; 

      if (puType.effect === 'speed' && gameState === "playing") {
          balls.forEach(b => {
              if (!b.onPaddle) {
                  let mag = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
                  b.vx = (b.vx/mag) * ballSpeed; b.vy = (b.vy/mag) * ballSpeed;
              }
          });
      }

      const expiryTimer = setTimeout(() => {
          resetPowerupEffects();
          activePowerup = null;
          messageCenter.textContent = "Effet termin√©.";
      }, puType.duration);
      
      activePowerup = { type: puType, timer: expiryTimer, endTime: Date.now() + puType.duration };
      messageCenter.textContent = `BONUS : ${puType.symbol}`;
  }

  function resetPowerupEffects() {
      paddle.width = defaultPaddleWidth;
      ballSpeed = defaultBallSpeed;
      paddle.sticky = false;
      paddle.laser = false;
      
      if (gameState === "playing") {
          balls.forEach(b => {
             if (b.onPaddle) {
                 b.onPaddle = false;
                 b.vy = -ballSpeed;
                 b.vx = (Math.random() - 0.5) * 4;
             }
             if (!b.onPaddle) {
                let mag = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
                b.vx = (b.vx/mag) * ballSpeed; b.vy = (b.vy/mag) * ballSpeed;
             }
          });
      }
  }

  function update() {
      if (gameState === "playing") {
          paddle.x += paddle.dx;
          if(paddle.x < 0) paddle.x = 0;
          if(paddle.x + paddle.width > GAME_WIDTH) paddle.x = GAME_WIDTH - paddle.width;

          for (let i = balls.length - 1; i >= 0; i--) {
              let b = balls[i];

              if (b.onPaddle) {
                  b.x = paddle.x + b.stuckOffset;
                  b.y = paddle.y - b.radius - 1;
                  continue;
              }

              b.trail.push({x: b.x, y: b.y});
              if(b.trail.length > 8) b.trail.shift();

              b.x += b.vx; b.y += b.vy;

              if(b.x + b.radius > GAME_WIDTH || b.x - b.radius < 0) { 
                  b.vx = -b.vx; 
                  sHit(); 
                  if (Math.abs(b.vx) < 1.0) {
                       b.vx = (b.x < GAME_WIDTH/2) ? 1.5 : -1.5;
                  }
              }
              if (Math.abs(b.vx) < 0.35) {
                   b.vx += (b.vx >= 0 ? 0.05 : -0.05);
              }

              if(b.y - b.radius < 0) { b.vy = -b.vy; sHit(); }
              
              if(b.y - b.radius > GAME_HEIGHT) { 
                  balls.splice(i, 1);
                  continue; 
              }

              if(b.y + b.radius >= paddle.y && b.y - b.radius <= paddle.y + paddle.height &&
                 b.x >= paddle.x && b.x <= paddle.x + paddle.width) {
                  
                  comboCount = 0;

                  if (paddle.sticky) {
                      b.onPaddle = true;
                      b.stuckOffset = b.x - paddle.x;
                      b.vx = 0; b.vy = 0;
                  } else {
                      let hitPoint = (b.x - paddle.x) / paddle.width;
                      let angle = (hitPoint - 0.5) * (Math.PI / 1.5); 
                      b.vy = -Math.abs(Math.cos(angle) * ballSpeed);
                      b.vx = Math.sin(angle) * ballSpeed;
                      b.y = paddle.y - b.radius - 1; 

                      if (Math.abs(b.vx) < 0.5) {
                          b.vx = (Math.random() > 0.5 ? 1 : -1) * 0.8;
                      }
                      sHit(); 
                  }
              }
              
              let hitBrick = false;
              for(let c=0; c<BRICK_COLS; c++) {
                for(let r=0; r<bricks[c].length; r++) {
                    let brick = bricks[c][r];
                    if(brick.status === 1 && !hitBrick) {
                        if(b.x + b.radius > brick.x && b.x - b.radius < brick.x + BRICK_WIDTH &&
                           b.y + b.radius > brick.y && b.y - b.radius < brick.y + BRICK_HEIGHT) {
                            
                            const prevX = b.x - b.vx;
                            const prevY = b.y - b.vy;
                            if (prevY + b.radius <= brick.y || prevY - b.radius >= brick.y + BRICK_HEIGHT) b.vy = -b.vy;
                            else b.vx = -b.vx;
                            
                            brick.hp--;
                            
                            if (brick.hp <= 0) {
                                brick.status = 0; 
                                comboCount++;
                                let comboMult = 1 + (comboCount > 1 ? (comboCount * 0.5) : 0);
                                let pts = Math.floor(10 * level * comboMult);
                                score += pts; 
                                let txt = `+${pts}`;
                                if(comboCount > 1) txt += ` (x${comboCount})`;
                                spawnFloatingText(brick.x + BRICK_WIDTH/2, brick.y, txt, comboCount > 2 ? "#e67e22" : "#2ecc71"); 
                                sBrick(1 + (comboCount * 0.1)); 
                                triggerMicroShake();
                                triggerFlash(); 
                                spawnShockwave(brick.x + BRICK_WIDTH/2, brick.y + BRICK_HEIGHT/2); 
                                spawnParticles(brick.x + BRICK_WIDTH/2, brick.y + BRICK_HEIGHT/2, brick.color);
                                hitBrick = true; 

                                if (Math.random() < POWERUP_PROBABILITY) {
                                    const randomKey = POWERUP_KEYS[Math.floor(Math.random() * POWERUP_KEYS.length)];
                                    powerups.push({
                                        x: brick.x + BRICK_WIDTH/2, y: brick.y + BRICK_HEIGHT/2,
                                        type: POWERUP_TYPES[randomKey], vy: POWERUP_DROP_SPEED
                                    });
                                }
                            } else {
                                sCrack();
                                spawnParticles(brick.x + BRICK_WIDTH/2, brick.y + BRICK_HEIGHT/2, "#fff"); 
                                hitBrick = true;
                            }
                        }
                    }
                }
              }
          }

          if (balls.length === 0) {
              loseLife();
              if (gameState !== "gameover") animationId = requestAnimationFrame(update);
              return;
          }

          for (let i = bullets.length - 1; i >= 0; i--) {
              let bul = bullets[i];
              bul.y -= 10;
              if (bul.y < 0) { bullets.splice(i, 1); continue; }
              
              let hit = false;
              for(let c=0; c<BRICK_COLS; c++) {
                  for(let r=0; r<bricks[c].length; r++) {
                      let br = bricks[c][r];
                      if (br.status === 1) {
                          if (bul.x > br.x && bul.x < br.x + BRICK_WIDTH && bul.y < br.y + BRICK_HEIGHT && bul.y > br.y) {
                              br.hp--; 
                              if(br.hp <= 0) {
                                  br.status = 0; score += 10; 
                                  spawnFloatingText(br.x + BRICK_WIDTH/2, br.y, "+10", "#e74c3c");
                                  sBrick(); hit = true;
                                  triggerMicroShake(); 
                                  spawnShockwave(br.x + BRICK_WIDTH/2, br.y + BRICK_HEIGHT/2);
                                  spawnParticles(br.x+BRICK_WIDTH/2, br.y+BRICK_HEIGHT/2, br.color);
                              } else {
                                  sCrack();
                                  spawnParticles(br.x+BRICK_WIDTH/2, br.y+BRICK_HEIGHT/2, "#fff");
                                  hit = true;
                              }
                              bullets.splice(i, 1);
                              break;
                          }
                      }
                  }
                  if(hit) break;
              }
          }

          const puHalfW = POWERUP_WIDTH / 2;
          const puHalfH = POWERUP_HEIGHT / 2;
          for (let i = powerups.length - 1; i >= 0; i--) {
              let pu = powerups[i];
              pu.y += pu.vy; 
              if (pu.y - puHalfH > GAME_HEIGHT) { powerups.splice(i, 1); continue; }
              if (pu.y + puHalfH >= paddle.y && pu.y - puHalfH <= paddle.y + paddle.height &&
                  pu.x + puHalfW >= paddle.x && pu.x - puHalfW <= paddle.x + paddle.width) {
                  applyPowerupEffect(pu.type);
                  powerups.splice(i, 1); 
              }
          }

          inGameTriggerCounter++;
          if (inGameTriggerCounter >= IN_GAME_CHECK_INTERVAL) {
              if (Math.random() < IN_GAME_PROBABILITY) triggerCharacter('inGame');
              inGameTriggerCounter = 0;
          }

      } else if (gameState === "waiting" || gameState === "recovering") {
          balls[0].x = paddle.x + paddle.width/2;
          balls[0].y = paddle.y - balls[0].radius - 2;
          balls[0].trail = []; 
          paddle.x += paddle.dx;
          if(paddle.x < 0) paddle.x = 0;
          if(paddle.x + paddle.width > GAME_WIDTH) paddle.x = GAME_WIDTH - paddle.width;
      }
      
      draw(); 
      updateUI();
      if (gameState !== "paused") animationId = requestAnimationFrame(update);
  }
  
  function launchBall() {
      if(gameState === "waiting" || gameState === "recovering") {
          if (gameState === "recovering" && resumeTimeout) { clearTimeout(resumeTimeout); resumeTimeout = null; }
          initAudioContext(); 
          let b = balls[0];
          b.onPaddle = false;
          b.vy = -ballSpeed;
          let initialVx = (Math.random() - 0.5) * ballSpeed;
          if (Math.abs(initialVx) < 1.0) initialVx = (initialVx >= 0 ? 1 : -1) * 1.0;
          b.vx = initialVx; 
          gameState = "playing"; 
          messageCenter.textContent = "";
          sStart();
          hideCharacters(); 
          comboCount = 0;
      }
      else if (gameState === "playing" && paddle.sticky) {
          let stuckBalls = balls.filter(b => b.onPaddle);
          if (stuckBalls.length > 0) {
              stuckBalls.forEach(b => {
                  b.onPaddle = false;
                  b.vy = -ballSpeed;
                  let angleFactor = (b.stuckOffset + paddle.width/2) / paddle.width; 
                  b.vx = (Math.random() - 0.5) * 4; 
              });
              sStart();
              comboCount = 0;
          }
      }
      else if (gameState === "playing" && paddle.laser) {
          bullets.push({x: paddle.x + 2, y: paddle.y});
          bullets.push({x: paddle.x + paddle.width - 6, y: paddle.y});
          sShoot();
      }
  }
  
  function levelUp() {
      level++;
      defaultBallSpeed += 0.5; 
      ballSpeed = defaultBallSpeed; 
      initBricks(); 
      resetBall(false); 
      messageCenter.innerHTML = `NIVEAU ${level} !!<br>CLIQUEZ POUR LANCER.`; 
      triggerCharacter('levelUp'); 
  }
  
  let resumeTimeout = null;
  function loseLife() {
      if (resumeTimeout) clearTimeout(resumeTimeout); 
      lives--; sDie(); 
      if (lives <= 0) {
          realGameOver();
      } else {
          gameContainer.classList.add("shake-effect");
          setTimeout(()=>gameContainer.classList.remove("shake-effect"), 500);
          resetBall(true); 
          messageCenter.innerHTML = `VIE PERDUE ! ${lives} restantes.<br>REPRISE AUTOMATIQUE DANS 2 SECONDES...`; 
          triggerCharacter('lifeLost'); 
          resumeTimeout = setTimeout(launchBall, 2000); 
      }
      updateUI();
  }

  function realGameOver() {
      gameState = "gameover";
      cancelAnimationFrame(animationId); animationId = null; 
      pauseOverlay.classList.add('visible'); pauseOverlay.style.display = 'flex';
      pauseOverlay.innerHTML = `GAME OVER<br>Score Final: ${score}<br><span>Cliquez pour rejouer</span>`;
      triggerCharacter('gameOver'); 
      checkAndSaveHighscore(score); 
  }

  function resetBall(isRecovery = false) {
      balls = [createBall(paddle.x + paddle.width/2, paddle.y - BALL_RADIUS - 2, 0, 0, true)];
      paddle.dx = 0; 
      bullets = [];
      resetPowerupEffects();
      gameState = isRecovery ? "recovering" : "waiting"; 
      comboCount = 0;
  }

  function resetGame() {
      hideCharacters();
      if (animationId) cancelAnimationFrame(animationId); 
      if (resumeTimeout) clearTimeout(resumeTimeout);
      pauseOverlay.classList.remove('visible'); pauseOverlay.style.display = 'none';
      
      score = 0; level = 1; lives = 3; 
      ballSpeed = 6; defaultBallSpeed = 6; 
      paddle.width = PADDLE_WIDTH; defaultPaddleWidth = PADDLE_WIDTH;
      powerups = []; bullets = []; floatingTexts = []; shockwaves = [];
      if (activePowerup && activePowerup.timer) clearTimeout(activePowerup.timer);
      activePowerup = null;
      comboCount = 0;

      resizeCanvas(); initBricks(); 
      resetBall(false); 
      updateUI(); updateHighScores(); 
      
      messageCenter.textContent = "CLIQUEZ POUR D√âMARRER"; 
      setTimeout(() => triggerCharacter('intro'), 500); 
      animationId = requestAnimationFrame(update); 
  }
  
  function togglePause() {
      if (gameState === "playing" || gameState === "waiting" || gameState === "recovering") {
          cancelAnimationFrame(animationId); gameState = "paused"; 
          pauseOverlay.innerHTML = "PAUSE<br><span>Appuyez sur P pour reprendre</span>";
          pauseOverlay.style.display = "flex";
          setTimeout(() => pauseOverlay.classList.add('visible'), 10);
      } else if (gameState === "paused") {
          if (resumeTimeout) gameState = "recovering"; 
          else gameState = balls[0].onPaddle ? "waiting" : "playing"; 
          pauseOverlay.classList.remove('visible');
          setTimeout(() => pauseOverlay.style.display = "none", 200);
          animationId = requestAnimationFrame(update); 
      }
  }

  function movePaddleByInput(clientX) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = GAME_WIDTH / rect.width;
      const relativeX = (clientX - rect.left) * scaleX;
      paddle.x = relativeX - paddle.width / 2;
      if(paddle.x < 0) paddle.x = 0;
      if(paddle.x + paddle.width > GAME_WIDTH) paddle.x = GAME_WIDTH - paddle.width;
      paddle.dx = 0; 
  }

  /* --- INPUTS --- */
  pauseOverlay.addEventListener("click", () => { if (gameState === "gameover") resetGame(); });
  canvas.addEventListener("mousemove", (e) => { if(gameState !== "paused") movePaddleByInput(e.clientX); });
  canvas.addEventListener("mousedown", (e) => { launchBall(); e.preventDefault(); });
  document.addEventListener('keydown', e => {
      if(e.code === "ArrowLeft") paddle.dx = -8;
      if(e.code === "ArrowRight") paddle.dx = 8;
      if(e.code === "Space") { launchBall(); if(gameState === "gameover") resetGame(); e.preventDefault(); }
      if(e.code === "KeyP") togglePause();
  });
  document.addEventListener('keyup', e => {
      if((e.code === "ArrowLeft" && paddle.dx < 0) || (e.code === "ArrowRight" && paddle.dx > 0)) paddle.dx = 0;
  });
  document.getElementById("btn-left").addEventListener("touchstart", (e) => { e.preventDefault(); paddle.dx = -8; }, {passive: false});
  document.getElementById("btn-left").addEventListener("touchend", () => { if(paddle.dx < 0) paddle.dx = 0; });
  document.getElementById("btn-right").addEventListener("touchstart", (e) => { e.preventDefault(); paddle.dx = 8; }, {passive: false});
  document.getElementById("btn-right").addEventListener("touchend", () => { if(paddle.dx > 0) paddle.dx = 0; });
  document.getElementById("btn-launch").addEventListener("click", launchBall);
  startBtn.addEventListener("click", resetGame);
  
  updateHighScores();
  resetGame(); 
</script>
</body>
</html>