<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Tetris BTS CIEL - Lycée Simone Veil</title>

<style>
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
  }

  body {
    background: url("fond_lycee.jpg") no-repeat center center fixed;
    background-color: #2c3e50; 
    background-size: cover;
    color: #000;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
  }

  #main {
    background: rgba(255,255,255,0.92);
    border-radius: 16px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    box-sizing: border-box;
    box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    width: 98%;
    height: 98%;
    max-width: 1000px;
    justify-content: center; 
    position: relative;
    z-index: 1;
  }

  #header-group {
    text-align: center;
    margin-bottom: 5px;
  }

  #logo {
    width: 60px;
    height: auto;
    display: block;
    margin: 0 auto;
  }

  #title {
    font-size: 20px;
    font-weight: 900;
    color: #222;
    margin: 0;
  }

  #subtitle {
    font-size: 11px;
    color: #555;
    font-weight: 600;
  }

  #game-container {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    justify-content: center;
    height: 80vh; 
    width: 100%;
  }

  canvas#tetris {
    border: 3px solid #333;
    background: #fff;
    display: block;
    box-shadow: 5px 5px 15px rgba(0,0,0,0.2);
    height: 100%; 
    width: auto; 
    aspect-ratio: 1/2;
  }

  #side-panel {
    display: flex;
    flex-direction: column;
    gap: 8px;
    background: rgba(255,255,255,0.6);
    padding: 15px;
    border-radius: 10px;
    min-width: 180px;
    border: 2px solid #333;
    box-sizing: border-box;
    height: 100%;
    justify-content: center;
  }

  #next-piece-container {
    text-align: center;
    margin-bottom: 10px;
  }
  canvas#next {
    background: #fff;
    border: 2px solid #555;
    margin-top: 2px;
    width: 80px; 
    height: 80px;
  }

  #score-box, #level-box {
    text-align: center;
    margin-bottom: 5px;
  }

  .label-text {
    font-size: 12px;
    text-transform: uppercase;
    color: #555;
    font-weight: bold;
  }

  #score {
    font-size: 20px;
    font-weight: 900;
    color: #000;
  }

  #level {
    font-size: 18px;
    font-weight: bold;
    color: #000;
  }
  
  #rank-name {
    font-size: 14px;
    font-weight: 900;
    color: #d32f2f;
    margin-top: 2px;
    min-height: 20px;
  }

  #highscore-title {
    font-size: 14px;
    font-weight: bold;
    margin-top: 10px;
    text-decoration: underline;
  }

  #highscore-list {
    padding-left: 18px; 
    margin: 5px 0; 
    font-size: 13px;
    max-height: 150px;
    overflow-y: auto;
  }

  button {
    padding: 12px;
    border-radius: 6px;
    border: 2px solid #333;
    background: #fff;
    font-weight: bold;
    font-size: 13px;
    cursor: pointer;
    transition: background 0.2s;
    margin-top: 5px;
  }
  button:hover { background: #eee; }
  button:active { background: #ccc; }
  button:focus { outline: none; }

  #controls-info {
    font-size: 11px;
    line-height: 1.4;
    margin-top: 15px;
    color: #444;
    background: rgba(0,0,0,0.05);
    padding: 5px;
    border-radius: 4px;
  }

  #message-center {
    font-size: 18px;
    font-weight: 900;
    text-align: center;
    color: #d32f2f;
    min-height: 24px;
    margin-top: 5px;
  }

  /* --- CONTRÔLES MOBILE --- */
  #mobile-controls {
    display: none;
    width: 100%;
    justify-content: space-between;
    margin-top: 5px;
    gap: 10px;
    padding-bottom: 5px;
  }
   
  .pad-group {
    display: flex;
    gap: 15px;
  }

  .mob-btn {
    width: 55px;
    height: 55px;
    font-size: 24px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(255,255,255,0.9);
    border: 2px solid #333;
    border-radius: 50%;
    box-shadow: 0 4px 0 #333;
    touch-action: manipulation;
    user-select: none;
  }
  .mob-btn:active {
    transform: translateY(4px);
    box-shadow: none;
    background: #ddd;
  }
  .mob-btn.big {
    width: 65px;
    height: 65px;
    background: #ffeba7;
  }

  /* --- PROVISEUR + BULLE BD (en dehors du cadre) --- */
  #proviseur-box {
    position: absolute;
    left: calc(50% + 520px);  /* à droite du cadre (1000px/2 + marge) */
    bottom: 10px;
    display: none;
    pointer-events: none;
    z-index: 2;
  }

  #proviseur-img {
    height: auto;       /* personnage agrandi */
    max-height: 50vh;
  }

  #speech-bubble {
    position: absolute;
    left: 100%;
    bottom: 65%;
    margin-left: 12px;
    max-width: 320px;    /* augmente ça pour élargir la bulle */
    background: #fff;
    border-radius: 18px;
    border: 3px solid #333;
    padding: 10px 14px;
    font-size: 14px;
    font-weight: 700;
    color: #111;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
  }

  #speech-bubble::after {
    content: "";
    position: absolute;
    right: 100%;
    bottom: 20%;
    border-width: 10px;
    border-style: solid;
    border-color: transparent #333 transparent transparent;
  }

  #speech-bubble::before {
    content: "";
    position: absolute;
    right: 100%;
    bottom: 20%;
    margin-right: -2px;
    border-width: 9px;
    border-style: solid;
    border-color: transparent #fff transparent transparent;
  }

  @media (max-width: 800px) {
    #main { 
        width: 100%; height: 100%; padding: 5px; border-radius: 0; justify-content: space-between;
    }
    #header-group { display: none; }
    #game-container { height: 60vh; align-items: center; }
    #side-panel { display: none; } 
    #mobile-header { 
        display: flex; flex-direction: column; align-items: center; width: 95%; 
        font-weight: bold; font-size: 14px; margin-top: 5px;
        background: rgba(255,255,255,0.8); padding: 5px; border-radius: 8px;
    }
    #mobile-header-row { display: flex; justify-content: space-between; width: 100%; }
    #mob-rank { color: #d32f2f; font-size: 12px; margin-top: 2px; font-weight: 900;}

    #mobile-controls { display: flex; padding: 0 15px 15px 15px; box-sizing: border-box;}
    #message-center { font-size: 14px; margin-bottom: 5px; }

    #proviseur-box {
      left: auto;
      right: 5px;
      bottom: 5px;
    }
    #proviseur-img {
      height: 240px;
      max-height: 40vh;
    }
    #speech-bubble {
      max-width: 220px;
      font-size: 12px;
      left: auto;
      right: 100%;
      margin-left: 0;
      margin-right: 8px;
    }
    #speech-bubble::after,
    #speech-bubble::before {
      left: 100%;
      right: auto;
      border-color: transparent transparent transparent #333;
    }
    #speech-bubble::before {
      border-color: transparent transparent transparent #fff;
    }
  }
  
  @media (min-width: 801px) {
    #mobile-header { display: none; }
  }

</style>
</head>
<body>

<div id="main">

  <div id="header-group">
    <img id="logo" src="Logo.gif" alt="Logo BTS" onerror="this.style.display='none'">
    <div id="title">TETRIS – BTS CIEL</div>
    <div id="subtitle">Lycée Simone Veil - Noisiel</div>
  </div>

  <div id="mobile-header">
    <div id="mobile-header-row">
        <span id="mob-score">Score: 0</span>
        <span id="mob-level">Niv: 1</span>
    </div>
    <div id="mob-rank">Nouvelle Recrue</div>
  </div>

  <div id="game-container">
    <canvas id="tetris" width="800" height="1600"></canvas>

    <div id="side-panel">
      <div id="next-piece-container">
        <div style="font-weight:bold; margin-bottom:5px;">Suivante :</div>
        <canvas id="next" width="160" height="160"></canvas>
      </div>

      <div id="score-box">
        <div class="label-text">Score</div>
        <div id="score">0</div>
      </div>

      <div id="level-box">
        <div class="label-text">Niveau</div>
        <div id="level">1</div>
        <div id="rank-name">Nouvelle Recrue</div>
      </div>

      <div id="highscore-title">Meilleurs scores :</div>
      <ul id="highscore-list"></ul>

      <button id="start-btn">Recommencer</button>
      <button id="mute-btn">Son : ON</button>

      <div id="controls-info">
        <b>Contrôles :</b><br>
        ◀/▶/▼ : Bouger<br>
        ▲ : Hard Drop<br>
        Espace : Rotation<br>
        P : Pause
      </div>
    </div>
  </div>

  <div id="mobile-controls">
    <div class="pad-group">
      <button class="mob-btn" id="btn-left">◀</button>
      <button class="mob-btn" id="btn-down">▼</button>
      <button class="mob-btn" id="btn-right">▶</button>
    </div>
    <div class="pad-group">
      <button class="mob-btn big" id="btn-rotate">↻</button>
      <button class="mob-btn big" id="btn-drop">⤓</button>
    </div>
  </div>

  <div id="message-center">APPUYEZ SUR ESPACE POUR DÉMARRER</div>
</div>

<!-- PROVISEUR + BULLE BD, en dehors du cadre blanc -->
<div id="proviseur-box">
  <img id="proviseur-img" src="proviseur.png" alt="Proviseur du lycée">
  <div id="speech-bubble"></div>
</div>

<script>
  /* --- INITIALISATION --- */
  const canvas = document.getElementById("tetris");
  const ctx = canvas.getContext("2d");
  const nextCanvas = document.getElementById("next");
  const nextCtx = nextCanvas.getContext("2d");
   
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  nextCtx.imageSmoothingEnabled = true;
  nextCtx.imageSmoothingQuality = 'high';

  const scoreElem = document.getElementById("score");
  const levelElem = document.getElementById("level");
  const rankElem = document.getElementById("rank-name");

  const mobScoreElem = document.getElementById("mob-score");
  const mobLevelElem = document.getElementById("mob-level");
  const mobRankElem = document.getElementById("mob-rank");

  const messageCenter = document.getElementById("message-center");
  const startBtn = document.getElementById("start-btn");
  const muteBtn = document.getElementById("mute-btn");
  const highscoreList = document.getElementById("highscore-list");

  /* --- PROVISEUR --- */
  const proviseurBox = document.getElementById("proviseur-box");
  const speechBubble = document.getElementById("speech-bubble");
  let proviseurTimeout = null;

  const proviseurDialogues = {
    start: [
      "« Bienvenue en BTS CIEL… essayez de faire mieux que vos bulletins. »",
      "« On s’échauffe : comme à la rentrée, mais avec moins de paperasse. »",
      "« Tetris CIEL : si vous ragez déjà, attendez l’E4. »"
    ],
    line: [
      "« Voilà, une ligne propre. Si seulement vos copies étaient aussi alignées. »",
      "« Pas mal. Continuez comme ça et je signe la mention. »",
      "« Une ligne en moins, un neurone en plus : bon calcul. »",
      "« C’est ce que j’appelle de la gestion de stock efficace. »"
    ],
    level: [
      "« Changement de niveau : comme le passage en 2e année, mais sans rattrapage. »",
      "« Vous venez de monter d’un cran. Gardez ce rythme au conseil de classe. »",
      "« Nouveau niveau. On va voir si vous tenez la cadence. »"
    ],
    gameover: [
      "« GAME OVER… mais au lycée, on n’a pas de bouton Recommencer. »",
      "« Conseil du proviseur : révisez la stratégie avant la prochaine partie. »",
      "« Ça, c’est ce qu’on appelle une commission d’appel ratée. »"
    ],
    generic: [
      "« Les CIEL, pensez à sauvegarder… vos neurones. »",
      "« Un Tetris bien rangé, c’est comme une bonne salle machine : ça respire. »",
      "« Pause ? Après avoir battu le highscore, pas avant. »",
      "« Vous jouez, mais n’oubliez pas que les notes, elles, sont bien réelles. »"
    ]
  };

  function getProviseurText(reason) {
    const pool = proviseurDialogues[reason] || proviseurDialogues.generic;
    return pool[Math.floor(Math.random() * pool.length)];
  }

  function showProviseur(reason) {
    const text = getProviseurText(reason);
    speechBubble.textContent = text;
    proviseurBox.style.display = "block";
    if (proviseurTimeout) clearTimeout(proviseurTimeout);
    proviseurTimeout = setTimeout(() => {
      proviseurBox.style.display = "none";
    }, 4500);
  }

  // Constantes Jeu
  const COLS = 10;
  const ROWS = 20;
  const TILE = 80; 
  const NEXT_TILE = 40; 
  const BASE_DROP = 800;

  let gameState = "waiting"; 
  let dropInterval = BASE_DROP;
  let dropCounter = 0;
  let lastTime = 0;
  let nextPieceMatrix = null; 

  let muted = false;
  let audioCtx = null;

  const cielRanks = [
      "Nouvelle Recrue",
      "Apprenti Câbleur",
      "Scripteur Bash",
      "Décodeur Binaire",
      "Admin Réseau",
      "Développeur C++",
      "Survivant de l'E4",
      "Expert Cybersécu",
      "Chef de Projet E6",
      "Major de Promo",
      "Diplômé CIEL",
      "Légende de Simone Veil"
  ];

  function getRankName(level) {
      if (level > cielRanks.length) return cielRanks[cielRanks.length - 1];
      return cielRanks[level - 1];
  }

  /* --- AUDIO --- */
  function initAudioContext() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) audioCtx = new AC();
    }
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }

  function playTone(freq, type, duration, vol) {
    if (muted || !audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  }

  function sStart()  { playTone(440, 'triangle', 0.5, 0.1); setTimeout(()=>playTone(880, 'triangle', 0.5, 0.1), 100); }
  function sMove()   { playTone(200, 'sine', 0.1, 0.05); }
  function sRotate() { playTone(300, 'square', 0.1, 0.05); }
  function sDrop()   { playTone(100, 'sawtooth', 0.2, 0.08); }
  function sLine()   { playTone(600, 'sine', 0.2, 0.1); setTimeout(()=>playTone(1200, 'sine', 0.4, 0.1), 100); }
  function sGameOver(){ playTone(150, 'sawtooth', 1.0, 0.2); setTimeout(()=>playTone(100, 'sawtooth', 1.0, 0.2), 300); }

  const FACE_COUNT = 10;
  const tileImages = [null];
  for (let i = 1; i <= FACE_COUNT; i++) {
    const img = new Image();
    img.src = "visage" + i + ".jpg";
    tileImages[i] = img;
  }

  const colors = [
    null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF', '#555555'
  ];

  /* --- LOGIQUE --- */
  function createMatrix(w, h) {
    const m = [];
    for (let y = 0; y < h; y++) m.push(new Array(w).fill(0));
    return m;
  }

  function createPiece(type) {
    switch (type) {
      case 'T': return [[0,1,0],[1,1,1],[0,0,0]];
      case 'O': return [[2,2],[2,2]];
      case 'L': return [[0,0,3],[3,3,3],[0,0,0]]; 
      case 'J': return [[4,0,0],[4,4,4],[0,0,0]];
      case 'I': return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
      case 'S': return [[0,6,6],[6,6,0],[0,0,0]];
      case 'Z': return [[7,7,0],[0,7,7],[0,0,0]];
    }
    return [[1]];
  }

  let arena = createMatrix(COLS, ROWS);

  const player = {
    pos: {x:0, y:0},
    matrix: null,
    score: 0,
    level: 1,
  };

  function drawGrid() {
    ctx.strokeStyle = "rgba(0,0,0,0.1)";
    ctx.lineWidth = 2; 
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath(); ctx.moveTo(x*TILE, 0); ctx.lineTo(x*TILE, ROWS*TILE); ctx.stroke();
    }
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath(); ctx.moveTo(0, y*TILE); ctx.lineTo(COLS*TILE, y*TILE); ctx.stroke();
    }
  }

  // Dessine la matrice de blocs (sans contour spécial pour la pièce active)
  function drawMatrix(matrix, offset, context = ctx, tileSize = TILE) {
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          const px = (x + offset.x) * tileSize;
          const py = (y + offset.y) * tileSize;

          if (value === 99) {
            context.fillStyle = "#555";
            context.fillRect(px, py, tileSize, tileSize);
            return;
          }

          const imgIndex = (value % FACE_COUNT) || 1; 
          const img = tileImages[imgIndex];

          if (img && img.complete && img.naturalWidth !== 0) {
            context.drawImage(img, px, py, tileSize, tileSize);
          } else {
            context.fillStyle = colors[value % colors.length] || 'grey';
            context.fillRect(px, py, tileSize, tileSize);

            // léger relief (pour les blocs posés ou l'ombre)
            context.lineWidth = 3; 
            context.strokeStyle = 'rgba(255,255,255,0.4)';
            context.strokeRect(px+2, py+2, tileSize-4, tileSize-4);
            context.fillStyle = 'rgba(0,0,0,0.15)';
            context.fillRect(px+6, py+6, tileSize-12, tileSize-12);
          }
        }
      });
    });
  }

  function drawNextPiece() {
    if (!nextPieceMatrix) return;
    nextCtx.fillStyle = "#fff";
    nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
    
    const offsetX = (4 - nextPieceMatrix[0].length) / 2;
    const offsetY = (4 - nextPieceMatrix.length) / 2;
    
    drawMatrix(nextPieceMatrix, {x: offsetX, y: offsetY}, nextCtx, NEXT_TILE);
  }

  function merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          arena[y + player.pos.y][x + player.pos.x] = value;
        }
      });
    });
  }

  function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for (let y = 0; y < m.length; ++y) {
      for (let x = 0; x < m[y].length; ++x) {
        if (m[y][x] !== 0 &&
           (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  function arenaSweep() {
    let lines = 0;
    outer: for (let y = arena.length - 1; y > 0; --y) {
      for (let x = 0; x < arena[y].length; ++x) {
        if (arena[y][x] === 0) {
          continue outer;
        }
      }
      const row = arena.splice(y, 1)[0].fill(0);
      arena.unshift(row);
      ++y;
      lines++;
    }
    if (lines > 0) {
      sLine();
      const linePoints = [0, 40, 100, 300, 1200];
      player.score += linePoints[lines] * player.level;
      if (player.score > player.level * 1000) {
        player.level++;
        dropInterval = Math.max(100, 800 - (player.level * 50));
        showProviseur("level");
      } else if (Math.random() < 0.4) {
        showProviseur("line");
      }
      updateScore();
    } else if (Math.random() < 0.05) {
      showProviseur("generic");
    }
  }

  function updateScore() {
    scoreElem.textContent = player.score;
    levelElem.textContent = player.level;
    
    const currentRank = getRankName(player.level);
    rankElem.textContent = currentRank;

    mobScoreElem.textContent = "Score: " + player.score;
    mobLevelElem.textContent = "Niv: " + player.level;
    mobRankElem.textContent = currentRank;
  }

  function playerReset() {
    const pieces = 'ILJOTSZ';
    if (nextPieceMatrix === null) {
        nextPieceMatrix = createPiece(pieces[pieces.length * Math.random() | 0]);
    }
    player.matrix = nextPieceMatrix;
    nextPieceMatrix = createPiece(pieces[pieces.length * Math.random() | 0]);
    drawNextPiece();

    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

    if (collide(arena, player)) {
      handleGameOver();
    }
  }

  function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      sDrop();
      arenaSweep();
      playerReset();
    }
    dropCounter = 0;
  }

  function hardDrop() {
    while (!collide(arena, player)) {
      player.pos.y++;
    }
    player.pos.y--; 
    merge(arena, player);
    sDrop();
    arenaSweep();
    playerReset();
  }

  function playerRotate(dir) {
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while (collide(arena, player)) {
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if (offset > player.matrix[0].length) {
        rotate(player.matrix, -dir);
        player.pos.x = pos;
        return;
      }
    }
    sRotate();
  }

  function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
      for (let x = 0; x < y; ++x) {
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if (dir > 0) matrix.forEach(row => row.reverse());
    else matrix.reverse();
  }

  // --- Contour qui suit la forme de la pièce ---
  function drawPieceOutline(matrix, pos) {
    ctx.lineWidth = 4;
    ctx.strokeStyle = "#000";
    ctx.beginPath();

    const h = matrix.length;
    const w = matrix[0].length;

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        if (matrix[y][x] === 0) continue;

        const worldX = pos.x + x;
        const worldY = pos.y + y;

        const px = worldX * TILE;
        const py = worldY * TILE;

        // voisin gauche vide → dessiner bord gauche
        if (x === 0 || matrix[y][x - 1] === 0) {
          ctx.moveTo(px, py);
          ctx.lineTo(px, py + TILE);
        }
        // voisin droit vide → bord droit
        if (x === w - 1 || matrix[y][x + 1] === 0) {
          ctx.moveTo(px + TILE, py);
          ctx.lineTo(px + TILE, py + TILE);
        }
        // voisin haut vide → bord haut
        if (y === 0 || matrix[y - 1][x] === 0) {
          ctx.moveTo(px, py);
          ctx.lineTo(px + TILE, py);
        }
        // voisin bas vide → bord bas
        if (y === h - 1 || matrix[y + 1][x] === 0) {
          ctx.moveTo(px, py + TILE);
          ctx.lineTo(px + TILE, py + TILE);
        }
      }
    }

    ctx.stroke();
  }

  // --- Rendu principal ---
  function draw() {
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    drawGrid();
    drawMatrix(arena, {x:0, y:0});   // blocs posés

    if (gameState === "playing") {
      // GHOST
      const ghost = {
        matrix: player.matrix,
        pos: {x: player.pos.x, y: player.pos.y}
      };
      while (!collide(arena, ghost)) {
        ghost.pos.y++;
      }
      ghost.pos.y--;
      
      ctx.globalAlpha = 0.2;
      drawMatrix(ghost.matrix, ghost.pos, ctx, TILE);
      ctx.globalAlpha = 1;

      // Pièce active
      drawMatrix(player.matrix, player.pos, ctx, TILE);

      // Contour qui suit la forme de la pièce
      drawPieceOutline(player.matrix, player.pos);
    }
  }

  function update(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;

    if (gameState === "playing") {
      dropCounter += deltaTime;
      if (dropCounter > dropInterval) {
        playerDrop();
      }
    }

    draw();
    if (gameState !== "gameover") { 
        requestAnimationFrame(update);
    }
  }

  /* --- GAME OVER & SCORES --- */
  function loadHighScores() {
    try { return JSON.parse(localStorage.getItem("tetris_scores") || "[]"); } catch { return []; }
  }
  function saveHighScores(list) {
    localStorage.setItem("tetris_scores", JSON.stringify(list));
  }
  function refreshHighScoreList() {
    const scores = loadHighScores();
    highscoreList.innerHTML = "";
    scores.forEach(s => {
      const li = document.createElement("li");
      li.textContent = `${s.name} : ${s.score}`;
      highscoreList.appendChild(li);
    });
  }

  function addHighScore(score) {
    setTimeout(() => {
        let name = prompt("GAME OVER ! \nGrade atteint : " + getRankName(player.level) + "\nTon pseudo :", "Etudiant CIEL");
        if (!name) return;
        name = name.trim().substring(0, 10);

        const scores = loadHighScores();
        scores.push({name, score});
        scores.sort((a,b)=>b.score-a.score);
        if (scores.length > 5) scores.length = 5; 
        saveHighScores(scores);
        refreshHighScoreList();
    }, 100); 
  }

  function handleGameOver() {
    gameState = "animating";
    sGameOver();
    messageCenter.textContent = "GAME OVER";
    showProviseur("gameover");

    let y = ROWS - 1;
    const animInterval = setInterval(() => {
        if (y < 0) {
            clearInterval(animInterval);
            addHighScore(player.score);
            gameState = "gameover";
            messageCenter.textContent = "GAME OVER — ESPACE POUR REJOUER";
            return;
        }
        arena[y].fill(99);
        draw(); 
        y--;
    }, 40);
  }

  function resetGame() {
    arena.forEach(row => row.fill(0));
    player.score = 0;
    player.level = 1;
    dropInterval = BASE_DROP;
    updateScore();
    nextPieceMatrix = null;
    playerReset();
    dropCounter = 0;
    gameState = "playing";
    messageCenter.textContent = "";
    sStart();
    showProviseur("start");
    requestAnimationFrame(update);
  }

  /* --- INPUTS --- */
  document.addEventListener("keydown", event => {
    if (!audioCtx) initAudioContext();

    if (event.code === "Space" && (gameState === "waiting" || gameState === "gameover")) {
        resetGame();
        return;
    }

    if (gameState === "playing") {
      switch(event.code) {
        case "ArrowLeft": 
        case "KeyQ": 
          player.pos.x--;
          if (collide(arena, player)) player.pos.x++; else sMove();
          break;
        case "ArrowRight": 
        case "KeyD":
          player.pos.x++;
          if (collide(arena, player)) player.pos.x--; else sMove();
          break;
        case "ArrowDown": 
        case "KeyS":
          playerDrop();
          break;
        case "ArrowUp": 
        case "KeyZ": 
           hardDrop();
           break;
        case "Space":
          playerRotate(1);
          break;
        case "KeyP":
          gameState = "paused";
          messageCenter.textContent = "PAUSE";
          break;
      }
    } else if (gameState === "paused" && event.code === "KeyP") {
        gameState = "playing";
        messageCenter.textContent = "";
    }
  });

  const setupMobileBtn = (id, action) => {
    const btn = document.getElementById(id);
    btn.addEventListener("touchstart", (e) => { e.preventDefault(); if(!audioCtx) initAudioContext(); action(); });
    btn.addEventListener("click", (e) => { if(!audioCtx) initAudioContext(); action(); });
  };

  setupMobileBtn("btn-left", () => { if(gameState==="playing") { player.pos.x--; if(collide(arena, player)) player.pos.x++; else sMove(); draw(); }});
  setupMobileBtn("btn-right", () => { if(gameState==="playing") { player.pos.x++; if(collide(arena, player)) player.pos.x--; else sMove(); draw(); }});
  setupMobileBtn("btn-down", () => { if(gameState==="playing") playerDrop(); draw(); });
  setupMobileBtn("btn-rotate", () => { if(gameState==="playing") playerRotate(1); draw(); });
  setupMobileBtn("btn-drop", () => { if(gameState==="playing") hardDrop(); draw(); });

  startBtn.addEventListener("click", () => {
      startBtn.blur();  // évite que Space reclique sur le bouton
      if(!audioCtx) initAudioContext();
      resetGame();
  });

  muteBtn.addEventListener("click", () => {
      muteBtn.blur();
      muted = !muted;
      muteBtn.textContent = muted ? "Son : OFF" : "Son : ON";
      if(!muted && !audioCtx) initAudioContext();
  });

  refreshHighScoreList();
  updateScore();
  draw(); 

</script>
</body>
</html>
