<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Tetris BTS CIEL - Lycée Simone Veil</title>

<style>
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    overscroll-behavior: none;
  }

  body {
    background: url("fond_lycee.jpg") no-repeat center center fixed;
    background-color: #2c3e50; 
    background-size: cover;
    color: #000;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
  }

  #main {
    background: rgba(255,255,255,0.94);
    border-radius: 16px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    box-sizing: border-box;
    box-shadow: 0 15px 35px rgba(0,0,0,0.6);
    width: 98%;
    height: 98%;
    max-width: 1000px;
    justify-content: center; 
    position: relative;
    z-index: 1;
    backdrop-filter: blur(5px);
  }

  /* --- EFFET DE SECOUSSE (SHAKE) --- */
  @keyframes shake {
    10%, 90% { transform: translate3d(-1px, 0, 0); }
    20%, 80% { transform: translate3d(2px, 0, 0); }
    30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
    40%, 60% { transform: translate3d(4px, 0, 0); }
  }
  .shake-effect {
    animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
  }

  #header-group {
    text-align: center;
    margin-bottom: 5px;
  }

  #logo {
    width: 60px;
    height: auto;
    display: block;
    margin: 0 auto;
  }

  #title {
    font-size: 20px;
    font-weight: 900;
    color: #222;
    margin: 0;
    letter-spacing: -0.5px;
  }

  #subtitle {
    font-size: 11px;
    color: #555;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  #game-container {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    justify-content: center;
    height: 80vh; 
    width: 100%;
    position: relative;
  }

  /* Overlay de pause */
  #pause-overlay {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(4px);
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 50;
    color: white;
    font-weight: 900;
    font-size: 40px;
    text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    border-radius: 4px;
  }
  #pause-overlay span { font-size: 14px; font-weight: normal; margin-top: 10px; opacity: 0.8; }

  canvas#tetris {
    border: 4px solid #333;
    background: linear-gradient(180deg, #fff 0%, #f4f4f4 100%);
    display: block;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.1), 5px 5px 15px rgba(0,0,0,0.3);
    height: 100%; 
    width: auto; 
    aspect-ratio: 1/2;
    border-radius: 4px;
    position: relative;
    z-index: 5;
  }

  #side-panel {
    display: flex;
    flex-direction: column;
    gap: 8px;
    background: rgba(255,255,255,0.7);
    padding: 15px;
    border-radius: 10px;
    min-width: 180px;
    border: 2px solid #333;
    box-sizing: border-box;
    height: 100%;
    justify-content: flex-start; /* Changé pour aligner en haut */
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    overflow-y: auto; /* Au cas où écran petit */
  }

  /* Conteneur Next et Hold alignés */
  .preview-box {
    text-align: center;
    margin-bottom: 5px;
    background: rgba(255,255,255,0.5);
    padding: 5px;
    border-radius: 6px;
    border: 1px solid rgba(0,0,0,0.1);
  }
  
  canvas.preview-canvas {
    background: rgba(255,255,255,0.8);
    border: 2px solid #555;
    margin-top: 2px;
    width: 60px; 
    height: 60px;
    border-radius: 4px;
  }
  
  #score-box, #level-box {
    text-align: center;
    margin-bottom: 5px;
    background: rgba(255,255,255,0.5);
    padding: 5px;
    border-radius: 6px;
    border: 1px solid rgba(0,0,0,0.1);
  }

  .label-text {
    font-size: 10px;
    text-transform: uppercase;
    color: #666;
    font-weight: 800;
    letter-spacing: 0.5px;
  }

  #score {
    font-size: 20px;
    font-weight: 900;
    color: #2c3e50;
    font-variant-numeric: tabular-nums;
  }

  #level {
    font-size: 18px;
    font-weight: bold;
    color: #2c3e50;
  }
    
  #rank-name {
    font-size: 12px;
    font-weight: 900;
    color: #d32f2f;
    margin-top: 2px;
    min-height: 20px;
    line-height: 1.2;
  }

  #highscore-title {
    font-size: 12px;
    font-weight: bold;
    margin-top: 5px;
    text-decoration: underline;
    text-transform: uppercase;
  }

  #highscore-list {
    padding-left: 18px; 
    margin: 5px 0; 
    font-size: 12px;
    max-height: 80px;
    overflow-y: auto;
    font-family: monospace;
  }

  button {
    padding: 10px;
    border-radius: 6px;
    border: 2px solid #333;
    background: #fff;
    font-weight: bold;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.1s;
    margin-top: 5px;
    box-shadow: 0 2px 0 #333;
  }
  button:hover { background: #f0f0f0; transform: translateY(-1px); }
  button:active { background: #ccc; transform: translateY(2px); box-shadow: none; }
  button:focus { outline: none; }

  #controls-info {
    font-size: 9px;
    line-height: 1.4;
    margin-top: auto;
    color: #444;
    background: rgba(0,0,0,0.05);
    padding: 5px;
    border-radius: 4px;
    border: 1px dashed #999;
  }

  #message-center {
    font-size: 18px;
    font-weight: 900;
    text-align: center;
    color: #d32f2f;
    min-height: 24px;
    margin-top: 5px;
    text-shadow: 0 1px 0 rgba(255,255,255,0.8);
    animation: pulse 2s infinite;
  }
  @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; } 100% { opacity: 0.8; } }

  #mobile-controls {
    display: none;
    width: 100%;
    justify-content: space-between;
    margin-top: 5px;
    gap: 10px;
    padding-bottom: 5px;
    touch-action: none;
  }
    
  .pad-group { display: flex; gap: 12px; }

  .mob-btn {
    width: 55px; height: 55px; font-size: 24px;
    display: flex; justify-content: center; align-items: center;
    background: linear-gradient(145deg, #ffffff, #e6e6e6);
    border: 2px solid #333; border-radius: 50%;
    box-shadow: 0 4px 0 #333;
    touch-action: manipulation; user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  .mob-btn:active { transform: translateY(4px); box-shadow: none; background: #ddd; }
  .mob-btn.big { width: 65px; height: 65px; background: linear-gradient(145deg, #ffeba7, #ffdf80); }
  .mob-btn.hold-btn { background: #e0f7fa; font-size: 14px; font-weight: bold; width: 45px; height: 45px; }

  /* --- PROVISEUR + BULLE BD --- */
  #proviseur-box {
    position: absolute;
    left: calc(50% + 400px); 
    bottom: 10px;
    display: none;
    cursor: pointer;
    z-index: 10;
    transition: transform 0.3s ease-out;
  }
  #proviseur-box.pop-in {
    animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }
  @keyframes popIn { from { transform: scale(0) translateY(50px); } to { transform: scale(1) translateY(0); } }

  #proviseur-img {
    height: auto;
    max-height: 50vh;
    filter: drop-shadow(5px 5px 10px rgba(0,0,0,0.4));
  }

  #speech-bubble {
    position: absolute;
    left: 100%;
    bottom: 65%;
    margin-left: 15px;
    max-width: 320px;
    background: #ffffff;
    border: 2px solid #2c3e50; 
    border-radius: 12px;
    padding: 16px 20px;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    font-size: 15px; 
    line-height: 1.5;
    font-weight: 600;
    color: #2c3e50;
    box-shadow: 0 8px 20px rgba(0,0,0,0.15);
  }

  #speech-bubble::after {
    content: ""; position: absolute; right: 100%; bottom: 20%;
    border-width: 10px; border-style: solid;
    border-color: transparent #2c3e50 transparent transparent;
  }
  #speech-bubble::before {
    content: ""; position: absolute; right: 100%; bottom: 20%;
    margin-right: -3px; border-width: 10px; border-style: solid;
    border-color: transparent #fff transparent transparent;
    z-index: 2;
  }

  @media (max-width: 800px) {
    #main { 
        width: 100%; height: 100%; padding: 5px; border-radius: 0; justify-content: space-between;
    }
    #header-group { display: none; }
    #game-container { height: 60vh; align-items: center; width: 100%; gap: 5px; }
    #side-panel { display: none; } 
    #mobile-header { 
        display: flex; flex-direction: column; align-items: center; width: 95%; 
        font-weight: bold; font-size: 14px; margin-top: 5px;
        background: rgba(255,255,255,0.8); padding: 5px; border-radius: 8px;
        border: 1px solid rgba(0,0,0,0.1);
    }
    #mobile-header-row { display: flex; justify-content: space-between; width: 100%; }
    #mob-rank { color: #d32f2f; font-size: 12px; margin-top: 2px; font-weight: 900;}

    #mobile-controls { 
      display: flex; padding: 0 10px 20px 10px; box-sizing: border-box; flex-wrap: wrap; justify-content: center;
    }
    #message-center { font-size: 14px; margin-bottom: 5px; }

    #proviseur-box {
      left: auto; right: 0px; bottom: 90px; top: auto;
      z-index: 20; pointer-events: none;
    }
    #proviseur-img { height: 100px; max-height: 20vh; }
    
    #speech-bubble {
      max-width: 200px;
      font-size: 13px;
      left: auto; right: 95%; bottom: 20%;
      margin-left: 0; margin-right: 10px;
      white-space: normal; pointer-events: auto;
    }

    #speech-bubble::after {
      left: 100%; right: auto; bottom: 20%;
      border-color: transparent transparent transparent #2c3e50;
    }
    #speech-bubble::before {
      left: 100%; right: auto; bottom: 20%;
      margin-right: 0; margin-left: -3px;
      border-color: transparent transparent transparent #fff;
    }
  }
    
  @media (min-width: 801px) {
    #mobile-header { display: none; }
  }

</style>
</head>
<body>

<div id="main">

  <div id="header-group">
    <img id="logo" src="Logo.gif" alt="Logo BTS" onerror="this.style.display='none'"> 
    <div id="title">TETRIS – BTS CIEL</div>
    <div id="subtitle">Lycée Simone Veil - Noisiel</div>
  </div>

  <div id="mobile-header">
    <div id="mobile-header-row">
        <span id="mob-score">Score: 0</span>
        <span id="mob-level">Niv: 1</span>
    </div>
    <div id="mob-rank">Nouvelle Recrue</div>
  </div>

  <div id="game-container">
    <canvas id="tetris" width="800" height="1600"></canvas>
    
    <div id="pause-overlay">
        PAUSE
        <span>Appuyez sur P pour reprendre</span>
    </div>

    <div id="side-panel">
      
      <div class="preview-box">
        <div class="label-text">Suivante</div>
        <canvas id="next" class="preview-canvas" width="120" height="120"></canvas>
      </div>

      <div class="preview-box">
        <div class="label-text">Réserve (C)</div>
        <canvas id="hold" class="preview-canvas" width="120" height="120"></canvas>
      </div>

      <div id="score-box">
        <div class="label-text">Score</div>
        <div id="score">0</div>
      </div>

      <div id="level-box">
        <div class="label-text">Niveau</div>
        <div id="level">1</div>
        <div id="rank-name">Nouvelle Recrue</div>
      </div>

      <div id="highscore-title">Meilleurs scores :</div>
      <ul id="highscore-list"></ul>

      <button id="start-btn">Recommencer</button>
      <button id="mute-btn">Son : ON</button>

      <div id="controls-info">
        <b>Contrôles :</b><br>
        ◀/▶/▼ : Bouger<br>
        ▲ : Hard Drop<br>
        Espace : Rotation<br>
        C / Maj : Réserve<br>
        P : Pause
      </div>
    </div>
  </div>

  <div id="mobile-controls">
    <div class="pad-group">
      <button class="mob-btn" id="btn-left">◀</button>
      <button class="mob-btn" id="btn-down">▼</button>
      <button class="mob-btn" id="btn-right">▶</button>
    </div>
    <div class="pad-group">
      <button class="mob-btn hold-btn" id="btn-hold">HOLD</button>
      <button class="mob-btn big" id="btn-rotate">↻</button>
      <button class="mob-btn big" id="btn-drop">⤓</button>
    </div>
  </div>

  <div id="message-center">APPUYEZ SUR ESPACE POUR DÉMARRER</div>
</div>

<div id="proviseur-box">
  <img id="proviseur-img" src="proviseur.png" alt="Proviseur du lycée">
  <div id="speech-bubble"></div>
</div>

<audio id="bg-music" loop>
    <source src="musique.mp3" type="audio/mpeg">
</audio>

<script>
  /* --- INITIALISATION --- */
  const canvas = document.getElementById("tetris");
  const ctx = canvas.getContext("2d");
  
  const nextCanvas = document.getElementById("next");
  const nextCtx = nextCanvas.getContext("2d");
  
  const holdCanvas = document.getElementById("hold");
  const holdCtx = holdCanvas.getContext("2d");
    
  ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
  nextCtx.imageSmoothingEnabled = true;
  holdCtx.imageSmoothingEnabled = true;

  const scoreElem = document.getElementById("score");
  const levelElem = document.getElementById("level");
  const rankElem = document.getElementById("rank-name");
  
  const pauseOverlay = document.getElementById("pause-overlay");

  const mobScoreElem = document.getElementById("mob-score");
  const mobLevelElem = document.getElementById("mob-level");
  const mobRankElem = document.getElementById("mob-rank");

  const messageCenter = document.getElementById("message-center");
  const startBtn = document.getElementById("start-btn");
  const muteBtn = document.getElementById("mute-btn");
  const highscoreList = document.getElementById("highscore-list");
  
  const gameContainer = document.getElementById("game-container");
  
  // Audio Element
  const bgMusic = document.getElementById("bg-music");
  bgMusic.volume = 0.3; // Volume musique à 30%

  /* --- GESTION PROVISEUR --- */
  const proviseurBox = document.getElementById("proviseur-box");
  const speechBubble = document.getElementById("speech-bubble");
  let proviseurTimeout = null;

  proviseurBox.addEventListener("click", () => hideProviseur());
  proviseurBox.addEventListener("touchstart", (e) => { e.preventDefault(); hideProviseur(); });

  function hideProviseur() {
      proviseurBox.classList.remove('pop-in');
      proviseurBox.style.display = "none";
  }

  const proviseurDialogues = {
    start: [
      "« Bienvenue en BTS CIEL. Essayez de faire mieux que vos bulletins. »",
      "« On s’échauffe : comme à la rentrée, mais avec moins de paperasse. »",
      "« Tetris CIEL : si vous ragez déjà, attendez l’épreuve E4. »"
    ],
    line: [
      "« Une ligne propre. Si seulement vos copies étaient aussi alignées. »",
      "« Pas mal. Continuez comme ça et je signe la mention. »",
      "« Une ligne en moins, un neurone en plus : bon calcul. »"
    ],
    tetris: [
      "« 4 lignes d'un coup ?! C'est la mention Très Bien assurée ! »",
      "« Incroyable ! Vous nettoyez le tableau mieux que le service d'entretien. »",
      "« Ça c'est du génie CIEL ! Je suis presque ému. »"
    ],
    level: [
      "« Changement de niveau : comme le passage en 2e année ! »",
      "« Vous montez d’un cran. Gardez ce rythme au conseil de classe. »"
    ],
    gameover: [
      "« GAME OVER… mais au lycée, on n’a pas de bouton Recommencer. »",
      "« Conseil du proviseur : révisez la stratégie avant la prochaine partie. »"
    ],
    generic: [
      "« Les CIEL, pensez à sauvegarder… vos neurones. »",
      "« Pause ? Après avoir battu le highscore, pas avant. »"
    ]
  };

  function showProviseur(reason) {
    const pool = proviseurDialogues[reason] || proviseurDialogues.generic;
    const text = pool[Math.floor(Math.random() * pool.length)];
    speechBubble.textContent = text;
    proviseurBox.style.display = "block";
    proviseurBox.classList.add('pop-in');
    
    if (proviseurTimeout) clearTimeout(proviseurTimeout);
    proviseurTimeout = setTimeout(() => hideProviseur(), 5000);
  }

  // --- Constantes Jeu ---
  const COLS = 10;
  const ROWS = 20;
  const TILE = 80; 
  const PREVIEW_TILE = 30; // Taille plus petite pour Hold/Next
  const BASE_DROP = 800;

  let gameState = "waiting"; 
  let dropInterval = BASE_DROP;
  let dropCounter = 0;
  let lastTime = 0;
  let nextPieceMatrix = null; 
  
  // VARIABLES HOLD (RESERVE)
  let holdPieceMatrix = null;
  let holdUsed = false; // Pour empêcher d'échanger 2 fois de suite

  let muted = false;
  let audioCtx = null;

  if(localStorage.getItem("tetris_muted") === "true") {
      muted = true;
      muteBtn.textContent = "Son : OFF";
  }

  const cielRanks = [
      "Nouvelle Recrue", "Apprenti Câbleur", "Scripteur Bash", "Décodeur Binaire",
      "Admin Réseau", "Développeur C++", "Survivant de l'E4", "Expert Cybersécu",
      "Chef de Projet E6", "Major de Promo", "Diplômé CIEL", "Légende du Lycée"
  ];

  function getRankName(level) {
      if (level > cielRanks.length) return cielRanks[cielRanks.length - 1];
      return cielRanks[level - 1];
  }

  /* --- AUDIO --- */
  function initAudioContext() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) audioCtx = new AC();
    }
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
    // Lancer la musique si pas mute
    if (!muted) bgMusic.play().catch(e => console.log("Clic requis pour musique"));
  }

  function playModernTone(type, startFreq, endFreq, duration, vol) {
    if (muted || !audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    osc.type = type; 
    osc.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
    if (endFreq && endFreq !== startFreq) {
        osc.frequency.exponentialRampToValueAtTime(endFreq, audioCtx.currentTime + duration);
    }

    gain.gain.setValueAtTime(0, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  }

  function sMove() { 
      if (muted || !audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(200, audioCtx.currentTime);
      gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.1);
  }

  function sStart() { 
      playModernTone('sine', 523.25, 523.25, 0.6, 0.1);
      setTimeout(() => playModernTone('sine', 659.25, 659.25, 0.6, 0.1), 100);
      setTimeout(() => playModernTone('sine', 783.99, 783.99, 0.8, 0.1), 200);
  }

  function sRotate() { playModernTone('sine', 300, 500, 0.15, 0.08); }
  function sDrop() { playModernTone('sine', 180, 50, 0.2, 0.15); }
  function sLine() { 
      playModernTone('triangle', 880, 880, 0.3, 0.08);
      setTimeout(() => playModernTone('triangle', 1108, 1108, 0.3, 0.08), 50);
      setTimeout(() => playModernTone('triangle', 1318, 1760, 0.5, 0.1), 100);
  }
  function sTetris() {
      playModernTone('triangle', 523.25, 523.25, 0.8, 0.1);
      setTimeout(() => playModernTone('triangle', 659.25, 659.25, 0.8, 0.1), 80);
      setTimeout(() => playModernTone('triangle', 783.99, 783.99, 0.8, 0.1), 160);
      setTimeout(() => playModernTone('triangle', 1046.50, 1046.50, 1.2, 0.15), 240);
  }
  function sGameOver() { playModernTone('triangle', 400, 50, 1.5, 0.2); }
  
  // Petit son pour le Hold
  function sHold() { playModernTone('sine', 400, 600, 0.1, 0.1); }

  /* --- VISUELS --- */
  const FACE_COUNT = 11; 
  const tileImages = [null];
  for (let i = 1; i <= FACE_COUNT; i++) {
    const img = new Image();
    img.src = "visage" + i + ".jpg";
    tileImages[i] = img;
  }

  const colors = [
    null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF', '#555555'
  ];

  /* --- PARTICULES --- */
  let particles = [];
  function spawnParticles(x, y, color, amount = 10) {
    for (let i = 0; i < amount; i++) {
      particles.push({
        x: x + TILE / 2, y: y + TILE / 2,
        vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15,
        life: 1.0, color: color, size: Math.random() * 8 + 4
      });
    }
  }

  function updateAndDrawParticles(ctx) {
    for (let i = particles.length - 1; i >= 0; i--) {
      let p = particles[i];
      p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life -= 0.03;
      if (p.life <= 0) { particles.splice(i, 1); continue; }
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
      ctx.globalAlpha = 1.0;
    }
  }

  /* --- LOGIQUE TETRIS --- */
  function createMatrix(w, h) {
    const m = [];
    for (let y = 0; y < h; y++) m.push(new Array(w).fill(0));
    return m;
  }

  const piecesTypes = 'ILJOTSZ';
  function createPiece(type) {
    const id = 1 + (Math.random() * FACE_COUNT | 0);
    let shape = [];
    switch (type) {
      case 'T': shape = [[0, id, 0],[id, id, id],[0, 0, 0]]; break;
      case 'O': shape = [[id, id],[id, id]]; break;
      case 'L': shape = [[0, 0, id],[id, id, id],[0, 0, 0]]; break;
      case 'J': shape = [[id, 0, 0],[id, id, id],[0, 0, 0]]; break;
      case 'I': shape = [[0, id, 0, 0],[0, id, 0, 0],[0, id, 0, 0],[0, id, 0, 0]]; break;
      case 'S': shape = [[0, id, id],[id, id, 0],[0, 0, 0]]; break;
      case 'Z': shape = [[id, id, 0],[0, id, id],[0, 0, 0]]; break;
    }
    shape.typeIdx = piecesTypes.indexOf(type) + 1; 
    shape.char = type; // Stocker la lettre pour le hold
    return shape;
  }

  let arena = createMatrix(COLS, ROWS);

  const player = {
    pos: {x:0, y:0},
    matrix: null,
    score: 0,
    level: 1,
  };

  let flashPhase = 0; 

  function drawGrid() {
    ctx.strokeStyle = "rgba(0, 0, 0, 0.08)";
    ctx.lineWidth = 1; 
    for (let x = 1; x < COLS; x++) {
      ctx.beginPath(); ctx.moveTo(x*TILE, 0); ctx.lineTo(x*TILE, ROWS*TILE); ctx.stroke();
    }
    for (let y = 1; y < ROWS; y++) {
      ctx.beginPath(); ctx.moveTo(0, y*TILE); ctx.lineTo(COLS*TILE, y*TILE); ctx.stroke();
    }
  }

  function drawBeveledRect(ctx, x, y, size, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x, y, size, size);
      ctx.lineWidth = size / 8;
      ctx.strokeStyle = "rgba(255,255,255,0.4)";
      ctx.beginPath(); ctx.moveTo(x, y+size); ctx.lineTo(x, y); ctx.lineTo(x+size, y); ctx.stroke();
      ctx.strokeStyle = "rgba(0,0,0,0.3)";
      ctx.beginPath(); ctx.moveTo(x+size, y); ctx.lineTo(x+size, y+size); ctx.lineTo(x, y+size); ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,0.1)";
      ctx.fillRect(x + size/4, y + size/4, size/2, size/2);
  }

  function drawMatrix(matrix, offset, context = ctx, tileSize = TILE) {
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          const px = (x + offset.x) * tileSize;
          const py = (y + offset.y) * tileSize;

          if (value === 99) {
            const progress = flashPhase / 10; 
            const scale = 1 - progress; 
            const center = tileSize / 2;
            context.fillStyle = `rgba(255, 215, 0, ${1 - progress})`;
            context.fillRect(px, py, tileSize, tileSize);
            context.save();
            context.translate(px + center, py + center);
            context.scale(scale, scale);
            context.fillStyle = "#fff"; 
            context.fillRect(-center, -center, tileSize, tileSize);
            context.restore();
            return;
          }

          const imgIndex = ((value - 1 + FACE_COUNT) % FACE_COUNT) + 1;
          const img = tileImages[imgIndex];
          const fallbackColor = colors[(matrix.typeIdx || (value % 7) + 1)] || '#888';

          if (img && img.complete && img.naturalWidth !== 0) {
            context.drawImage(img, px, py, tileSize, tileSize);
            context.fillStyle = "rgba(255,255,255,0.1)";
            context.fillRect(px, py, tileSize, tileSize/2);
            context.strokeStyle = "rgba(0,0,0,0.2)";
            context.strokeRect(px, py, tileSize, tileSize);
          } else {
            drawBeveledRect(context, px, py, tileSize, fallbackColor);
          }
        }
      });
    });
  }

  // Fonction générique pour dessiner Next et Hold
  function drawPreview(matrix, context, canvasElem) {
    context.clearRect(0,0, canvasElem.width, canvasElem.height);
    if (!matrix) return;
    const boxSize = 4; // Max taille piece
    const offsetX = (boxSize - matrix[0].length) / 2;
    const offsetY = (boxSize - matrix.length) / 2;
    drawMatrix(matrix, {x: offsetX, y: offsetY}, context, PREVIEW_TILE);
  }

  function drawNextPiece() { drawPreview(nextPieceMatrix, nextCtx, nextCanvas); }
  
  function drawHoldPiece() { 
      drawPreview(holdPieceMatrix, holdCtx, holdCanvas); 
      // Si utilisé, griser un peu le canvas
      holdCanvas.style.opacity = holdUsed ? "0.5" : "1";
  }

  function merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          arena[y + player.pos.y][x + player.pos.x] = value;
        }
      });
    });
  }

  function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for (let y = 0; y < m.length; ++y) {
      for (let x = 0; x < m[y].length; ++x) {
        if (m[y][x] !== 0 &&
           (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  function triggerShake() {
      gameContainer.classList.remove("shake-effect");
      void gameContainer.offsetWidth; 
      gameContainer.classList.add("shake-effect");
      setTimeout(() => { gameContainer.classList.remove("shake-effect"); }, 500);
  }

  function arenaSweep() {
    if (gameState === "lineflash" || gameState === "animating") return;

    const rowsToClear = [];
    for (let y = arena.length - 1; y >= 0; --y) {
      let full = true;
      for (let x = 0; x < arena[y].length; ++x) {
        if (arena[y][x] === 0) { full = false; break; }
      }
      if (full) rowsToClear.push(y);
    }

    if (rowsToClear.length === 0) {
      if (Math.random() < 0.05) showProviseur("generic");
      return;
    }

    gameState = "lineflash";
    const isTetris = (rowsToClear.length === 4);
    if (isTetris) { triggerShake(); showProviseur("tetris"); }

    rowsToClear.forEach(y => {
        for(let x=0; x<COLS; x++) {
            const pColor = (isTetris && Math.random() > 0.5) ? '#0DC2FF' : '#FFD700'; 
            spawnParticles(x*TILE, y*TILE, pColor, isTetris ? 8 : 4);
        }
        arena[y].fill(99);
    });

    let frame = 0;
    const flashInterval = setInterval(() => {
      frame++;
      flashPhase = frame; 
      draw(); 

      if (frame >= 8) {
        clearInterval(flashInterval);
        rowsToClear.sort((a, b) => b - a);
        rowsToClear.forEach(y => arena.splice(y, 1));
        while (arena.length < ROWS) arena.unshift(new Array(COLS).fill(0));

        const lines = rowsToClear.length;
        if (isTetris) sTetris(); else sLine();

        const linePoints = [0, 40, 100, 300, 1200];
        player.score += (linePoints[lines] || 1200) * player.level;

        if (player.score > player.level * 1000) {
          player.level++;
          dropInterval = Math.max(100, 800 - (player.level * 50));
          showProviseur("level");
        } else if (!isTetris && Math.random() < 0.5) showProviseur("line");

        updateScore();
        gameState = "playing";
        draw(); 
      }
    }, 40);
  }

  function updateScore() {
    scoreElem.textContent = player.score;
    levelElem.textContent = player.level;
    const currentRank = getRankName(player.level);
    rankElem.textContent = currentRank;
    mobScoreElem.textContent = "Score: " + player.score;
    mobLevelElem.textContent = "Niv: " + player.level;
    mobRankElem.textContent = currentRank;
  }

  function playerReset() {
    if (nextPieceMatrix === null) {
        nextPieceMatrix = createPiece(piecesTypes[piecesTypes.length * Math.random() | 0]);
    }
    player.matrix = nextPieceMatrix;
    nextPieceMatrix = createPiece(piecesTypes[piecesTypes.length * Math.random() | 0]);
    drawNextPiece();
    
    // Reset de l'état "déjà utilisé" du Hold
    holdUsed = false;
    drawHoldPiece();

    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

    if (collide(arena, player)) {
      handleGameOver();
    }
  }

  // --- LOGIQUE HOLD (RESERVE) ---
  function playerHold() {
      if (gameState !== "playing" || holdUsed) return;
      
      sHold();
      
      // Si la réserve est vide
      if (holdPieceMatrix === null) {
          holdPieceMatrix = player.matrix;
          playerReset(); // On prend la suivante
      } else {
          // Echange
          const temp = player.matrix;
          player.matrix = holdPieceMatrix;
          holdPieceMatrix = temp;
          
          // Repositionner en haut
          player.pos.y = 0;
          player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
      }
      
      holdUsed = true; // Verrouille pour ce tour
      drawHoldPiece();
  }

  function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      sDrop();
      player.matrix.forEach((row, y) => row.forEach((v, x) => {
          if(v) spawnParticles((player.pos.x+x)*TILE, (player.pos.y+y)*TILE, "#ddd", 2);
      }));
      arenaSweep();
      playerReset();
    }
    dropCounter = 0;
  }

  function hardDrop() {
    while (!collide(arena, player)) {
      player.pos.y++;
    }
    player.pos.y--; 
    merge(arena, player);
    sDrop();
    player.matrix.forEach((row, y) => row.forEach((v, x) => {
          if(v) spawnParticles((player.pos.x+x)*TILE, (player.pos.y+y)*TILE, "#fff", 5);
    }));
    arenaSweep();
    playerReset();
  }

  function playerRotate(dir) {
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while (collide(arena, player)) {
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if (offset > player.matrix[0].length) {
        rotate(player.matrix, -dir);
        player.pos.x = pos;
        return;
      }
    }
    sRotate();
  }

  function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
      for (let x = 0; x < y; ++x) {
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if (dir > 0) matrix.forEach(row => row.reverse());
    else matrix.reverse();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid();
    drawMatrix(arena, {x:0, y:0}); 
    updateAndDrawParticles(ctx);

    if (gameState === "playing" || gameState === "lineflash") {
      const ghost = {
        matrix: player.matrix,
        pos: {x: player.pos.x, y: player.pos.y}
      };
      while (!collide(arena, ghost)) {
        ghost.pos.y++;
      }
      ghost.pos.y--;
      
      ctx.save();
      ctx.globalAlpha = 0.2;
      const ghostColor = colors[player.matrix.typeIdx || 1];
      ghost.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
             ctx.fillStyle = ghostColor;
             ctx.fillRect((x + ghost.pos.x) * TILE, (y + ghost.pos.y) * TILE, TILE, TILE);
             ctx.strokeStyle = "#000";
             ctx.strokeRect((x + ghost.pos.x) * TILE, (y + ghost.pos.y) * TILE, TILE, TILE);
          }
        });
      });
      ctx.restore();

      drawMatrix(player.matrix, player.pos, ctx, TILE);
    }
  }

  function update(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;
    if (gameState === "playing") {
      dropCounter += deltaTime;
      if (dropCounter > dropInterval) playerDrop();
    }
    draw();
    if (gameState !== "gameover") requestAnimationFrame(update);
  }

  function loadHighScores() {
    try { return JSON.parse(localStorage.getItem("tetris_scores") || "[]"); } catch { return []; }
  }
  function saveHighScores(list) {
    localStorage.setItem("tetris_scores", JSON.stringify(list));
  }
  function refreshHighScoreList() {
    const scores = loadHighScores();
    highscoreList.innerHTML = "";
    scores.forEach(s => {
      const li = document.createElement("li");
      li.textContent = `${s.name} : ${s.score}`;
      highscoreList.appendChild(li);
    });
  }

  function addHighScore(score) {
    setTimeout(() => {
        let name = prompt("GAME OVER !\nGrade : " + getRankName(player.level) + "\nPseudo :", "Etudiant CIEL");
        if (!name) name = "Anonyme";
        name = name.trim().substring(0, 10);
        const scores = loadHighScores();
        scores.push({name, score});
        scores.sort((a,b)=>b.score-a.score);
        if (scores.length > 5) scores.length = 5; 
        saveHighScores(scores);
        refreshHighScoreList();
    }, 100); 
  }

  function handleGameOver() {
    gameState = "animating";
    bgMusic.pause(); // Stop musique
    sGameOver();
    messageCenter.textContent = "GAME OVER";
    showProviseur("gameover");
    let y = ROWS - 1;
    const animInterval = setInterval(() => {
        if (y < 0) {
            clearInterval(animInterval);
            addHighScore(player.score);
            gameState = "gameover";
            messageCenter.textContent = "GAME OVER — ESPACE POUR REJOUER";
            return;
        }
        arena[y].fill(99); 
        flashPhase = 5; 
        draw(); 
        y--;
    }, 30);
  }

  function resetGame() {
    arena.forEach(row => row.fill(0));
    player.score = 0;
    player.level = 1;
    dropInterval = BASE_DROP;
    particles = [];
    holdPieceMatrix = null; // Reset hold
    holdUsed = false;
    drawHoldPiece();
    updateScore();
    nextPieceMatrix = null;
    playerReset();
    dropCounter = 0;
    gameState = "playing";
    messageCenter.textContent = "";
    pauseOverlay.style.display = "none";
    sStart();
    
    // Relancer musique si active
    if (!muted) {
        bgMusic.currentTime = 0;
        bgMusic.play().catch(e => console.log(e));
    }
    
    showProviseur("start");
    requestAnimationFrame(update);
  }

  function togglePause() {
      if (gameState === "playing") {
          gameState = "paused";
          messageCenter.textContent = "";
          pauseOverlay.style.display = "flex";
          bgMusic.pause();
      } else if (gameState === "paused") {
          gameState = "playing";
          messageCenter.textContent = "";
          pauseOverlay.style.display = "none";
          if(!muted) bgMusic.play();
      }
  }

  document.addEventListener("keydown", event => {
    if (!audioCtx) initAudioContext();
    if (event.code === "Space" && (gameState === "waiting" || gameState === "gameover")) {
        resetGame();
        return;
    }
    if (gameState === "playing") {
      switch(event.code) {
        case "ArrowLeft": case "KeyQ": 
          player.pos.x--; if (collide(arena, player)) player.pos.x++; else sMove(); break;
        case "ArrowRight": case "KeyD":
          player.pos.x++; if (collide(arena, player)) player.pos.x--; else sMove(); break;
        case "ArrowDown": case "KeyS": playerDrop(); break;
        case "ArrowUp": case "KeyZ": hardDrop(); break;
        case "Space": playerRotate(1); break;
        case "KeyC": case "ShiftLeft": case "ShiftRight": playerHold(); break; // Touche C ou MAJ pour Hold
        case "KeyP": togglePause(); break;
      }
    } else if (gameState === "paused" && event.code === "KeyP") {
        togglePause();
    }
  });

  const setupMobileBtn = (id, action) => {
    const btn = document.getElementById(id);
    btn.addEventListener("touchstart", (e) => { 
        e.preventDefault(); if(!audioCtx) initAudioContext(); action(); 
    }, {passive: false});
    btn.addEventListener("click", (e) => { 
        if(!audioCtx) initAudioContext(); action(); 
    });
  };

  setupMobileBtn("btn-left", () => { if(gameState==="playing") { player.pos.x--; if(collide(arena, player)) player.pos.x++; else sMove(); draw(); }});
  setupMobileBtn("btn-right", () => { if(gameState==="playing") { player.pos.x++; if(collide(arena, player)) player.pos.x--; else sMove(); draw(); }});
  setupMobileBtn("btn-down", () => { if(gameState==="playing") playerDrop(); draw(); });
  setupMobileBtn("btn-rotate", () => { if(gameState==="playing") playerRotate(1); draw(); });
  setupMobileBtn("btn-drop", () => { if(gameState==="playing") hardDrop(); draw(); });
  setupMobileBtn("btn-hold", () => { if(gameState==="playing") playerHold(); draw(); });

  startBtn.addEventListener("click", () => { startBtn.blur(); if(!audioCtx) initAudioContext(); resetGame(); });
  
  muteBtn.addEventListener("click", () => { 
      muteBtn.blur(); 
      muted = !muted; 
      muteBtn.textContent = muted ? "Son : OFF" : "Son : ON"; 
      localStorage.setItem("tetris_muted", muted); 
      
      if(!muted) {
          if(!audioCtx) initAudioContext();
          if(gameState === "playing") bgMusic.play();
      } else {
          bgMusic.pause();
      }
  });

  refreshHighScoreList();
  updateScore();
  drawHoldPiece();
  draw(); 

  canvas.addEventListener("touchstart", (e) => {
      if(e.target === canvas) e.preventDefault();
      if (!audioCtx) initAudioContext();
      if (gameState === "waiting" || gameState === "gameover") resetGame();
  }, {passive: false});

</script>
</body>
</html>