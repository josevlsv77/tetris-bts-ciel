<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Tetris BTS CIEL - Lycée Simone Veil</title>

<style>
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
  }

  body {
    background: url("fond_lycee.jpg") no-repeat center center fixed;
    background-color: #2c3e50; 
    background-size: cover;
    color: #000;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #main {
    background: rgba(255,255,255,0.92);
    border-radius: 16px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    box-sizing: border-box;
    box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    width: 98%;
    height: 98%;
    max-width: 1000px;
    justify-content: center; 
  }

  #header-group {
    text-align: center;
    margin-bottom: 5px;
  }

  #logo {
    width: 60px;
    height: auto;
    display: block;
    margin: 0 auto;
  }

  #title {
    font-size: 20px;
    font-weight: 900;
    color: #222;
    margin: 0;
  }

  #subtitle {
    font-size: 11px;
    color: #555;
    font-weight: 600;
  }

  #game-container {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    justify-content: center;
    height: 80vh; 
    width: 100%;
  }

  /* Canvas principal */
  canvas#tetris {
    border: 3px solid #333;
    background: #fff;
    display: block;
    box-shadow: 5px 5px 15px rgba(0,0,0,0.2);
    height: 100%; 
    width: auto; 
    aspect-ratio: 1/2;
  }

  #side-panel {
    display: flex;
    flex-direction: column;
    gap: 8px;
    background: rgba(255,255,255,0.6);
    padding: 15px;
    border-radius: 10px;
    min-width: 180px; /* Un peu plus large pour les noms de grades */
    border: 2px solid #333;
    box-sizing: border-box;
    height: 100%;
    justify-content: center;
  }

  #next-piece-container {
    text-align: center;
    margin-bottom: 10px;
  }
  canvas#next {
    background: #fff;
    border: 2px solid #555;
    margin-top: 2px;
    width: 80px; 
    height: 80px;
  }

  #score-box, #level-box {
    text-align: center;
    margin-bottom: 5px;
  }

  .label-text {
    font-size: 12px;
    text-transform: uppercase;
    color: #555;
    font-weight: bold;
  }

  #score {
    font-size: 20px;
    font-weight: 900;
    color: #000;
  }

  #level {
    font-size: 18px;
    font-weight: bold;
    color: #000;
  }
  
  /* Style spécifique pour le grade BTS CIEL */
  #rank-name {
    font-size: 14px;
    font-weight: 900;
    color: #d32f2f; /* Rouge dynamique */
    margin-top: 2px;
    min-height: 20px;
  }

  #highscore-title {
    font-size: 14px;
    font-weight: bold;
    margin-top: 10px;
    text-decoration: underline;
  }

  #highscore-list {
    padding-left: 18px; 
    margin: 5px 0; 
    font-size: 13px;
    max-height: 150px;
    overflow-y: auto;
  }

  button {
    padding: 12px;
    border-radius: 6px;
    border: 2px solid #333;
    background: #fff;
    font-weight: bold;
    font-size: 13px;
    cursor: pointer;
    transition: background 0.2s;
    margin-top: 5px;
  }
  button:hover { background: #eee; }
  button:active { background: #ccc; }

  #controls-info {
    font-size: 11px;
    line-height: 1.4;
    margin-top: 15px;
    color: #444;
    background: rgba(0,0,0,0.05);
    padding: 5px;
    border-radius: 4px;
  }

  #message-center {
    font-size: 18px;
    font-weight: 900;
    text-align: center;
    color: #d32f2f;
    min-height: 24px;
    margin-top: 5px;
  }

  /* --- CONTRÔLES MOBILE --- */
  #mobile-controls {
    display: none;
    width: 100%;
    justify-content: space-between;
    margin-top: 5px;
    gap: 10px;
    padding-bottom: 5px;
  }
   
  .pad-group {
    display: flex;
    gap: 15px;
  }

  .mob-btn {
    width: 55px;
    height: 55px;
    font-size: 24px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(255,255,255,0.9);
    border: 2px solid #333;
    border-radius: 50%;
    box-shadow: 0 4px 0 #333;
    touch-action: manipulation;
    user-select: none;
  }
  .mob-btn:active {
    transform: translateY(4px);
    box-shadow: none;
    background: #ddd;
  }
  .mob-btn.big {
    width: 65px;
    height: 65px;
    background: #ffeba7;
  }

  @media (max-width: 800px) {
    #main { 
        width: 100%; height: 100%; padding: 5px; border-radius: 0; justify-content: space-between;
    }
    #header-group { display: none; }
    #game-container { height: 60vh; align-items: center; }
    #side-panel { display: none; } 
    #mobile-header { 
        display: flex; flex-direction: column; align-items: center; width: 95%; 
        font-weight: bold; font-size: 14px; margin-top: 5px;
        background: rgba(255,255,255,0.8); padding: 5px; border-radius: 8px;
    }
    #mobile-header-row { display: flex; justify-content: space-between; width: 100%; }
    #mob-rank { color: #d32f2f; font-size: 12px; margin-top: 2px; font-weight: 900;}

    #mobile-controls { display: flex; padding: 0 15px 15px 15px; box-sizing: border-box;}
    #message-center { font-size: 14px; margin-bottom: 5px; }
  }
  
  @media (min-width: 801px) {
    #mobile-header { display: none; }
  }

</style>
</head>
<body>

<div id="main">

  <div id="header-group">
    <img id="logo" src="Logo.gif" alt="Logo BTS" onerror="this.style.display='none'">
    <div id="title">TETRIS – BTS CIEL</div>
    <div id="subtitle">Lycée Simone Veil - Noisiel</div>
  </div>

  <div id="mobile-header">
    <div id="mobile-header-row">
        <span id="mob-score">Score: 0</span>
        <span id="mob-level">Niv: 1</span>
    </div>
    <div id="mob-rank">Nouvelle Recrue</div>
  </div>

  <div id="game-container">
    <canvas id="tetris" width="800" height="1600"></canvas>

    <div id="side-panel">
      <div id="next-piece-container">
        <div style="font-weight:bold; margin-bottom:5px;">Suivante :</div>
        <canvas id="next" width="160" height="160"></canvas>
      </div>

      <div id="score-box">
        <div class="label-text">Score</div>
        <div id="score">0</div>
      </div>

      <div id="level-box">
        <div class="label-text">Niveau</div>
        <div id="level">1</div>
        <div id="rank-name">Nouvelle Recrue</div>
      </div>

      <div id="highscore-title">Meilleurs scores :</div>
      <ul id="highscore-list"></ul>

      <button id="start-btn">Recommencer</button>
      <button id="mute-btn">Son : ON</button>

      <div id="controls-info">
        <b>Contrôles :</b><br>
        ◀/▶/▼ : Bouger<br>
        ▲ : Hard Drop<br>
        Espace : Rotation<br>
        P : Pause
      </div>
    </div>
  </div>

  <div id="mobile-controls">
    <div class="pad-group">
      <button class="mob-btn" id="btn-left">◀</button>
      <button class="mob-btn" id="btn-down">▼</button>
      <button class="mob-btn" id="btn-right">▶</button>
    </div>
    <div class="pad-group">
      <button class="mob-btn big" id="btn-rotate">↻</button>
      <button class="mob-btn big" id="btn-drop">⤓</button>
    </div>
  </div>

  <div id="message-center">APPUYEZ SUR ESPACE POUR DÉMARRER</div>
</div>

<script>
  /* --- INITIALISATION --- */
  const canvas = document.getElementById("tetris");
  const ctx = canvas.getContext("2d");
  const nextCanvas = document.getElementById("next");
  const nextCtx = nextCanvas.getContext("2d");
   
  // HD
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  nextCtx.imageSmoothingEnabled = true;
  nextCtx.imageSmoothingQuality = 'high';

  // Éléments UI
  const scoreElem = document.getElementById("score");
  const levelElem = document.getElementById("level");
  const rankElem = document.getElementById("rank-name"); // Élément pour le nom du grade

  const mobScoreElem = document.getElementById("mob-score");
  const mobLevelElem = document.getElementById("mob-level");
  const mobRankElem = document.getElementById("mob-rank"); // Élément mobile pour le grade

  const messageCenter = document.getElementById("message-center");
  const startBtn = document.getElementById("start-btn");
  const muteBtn = document.getElementById("mute-btn");
  const highscoreList = document.getElementById("highscore-list");

  // Constantes Jeu
  const COLS = 10;
  const ROWS = 20;
  const TILE = 80; 
  const NEXT_TILE = 40; 
  const BASE_DROP = 800;

  // Variables État
  let gameState = "waiting"; 
  let dropInterval = BASE_DROP;
  let dropCounter = 0;
  let lastTime = 0;
  let nextPieceMatrix = null; 

  // Audio
  let muted = false;
  let audioCtx = null;

  /* --- LISTE DES GRADES BTS CIEL --- */
  const cielRanks = [
      "Nouvelle Recrue",        // Niv 1
      "Apprenti Câbleur",       // Niv 2
      "Scripteur Bash",         // Niv 3
      "Décodeur Binaire",       // Niv 4
      "Admin Réseau",           // Niv 5
      "Développeur C++",        // Niv 6
      "Survivant de l'E4",      // Niv 7
      "Expert Cybersécu",       // Niv 8
      "Chef de Projet E6",      // Niv 9
      "Major de Promo",         // Niv 10
      "Diplômé CIEL",           // Niv 11
      "Légende de Simone Veil"  // Niv 12+
  ];

  function getRankName(level) {
      // Si le niveau dépasse la liste, on garde le dernier grade
      if (level > cielRanks.length) return cielRanks[cielRanks.length - 1];
      return cielRanks[level - 1];
  }

  /* --- AUDIO --- */
  function initAudioContext() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) audioCtx = new AC();
    }
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }

  function playTone(freq, type, duration, vol) {
    if (muted || !audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  }

  function sStart()  { playTone(440, 'triangle', 0.5, 0.1); setTimeout(()=>playTone(880, 'triangle', 0.5, 0.1), 100); }
  function sMove()   { playTone(200, 'sine', 0.1, 0.05); }
  function sRotate() { playTone(300, 'square', 0.1, 0.05); }
  function sDrop()   { playTone(100, 'sawtooth', 0.2, 0.08); }
  function sLine()   { playTone(600, 'sine', 0.2, 0.1); setTimeout(()=>playTone(1200, 'sine', 0.4, 0.1), 100); }
  function sGameOver(){ playTone(150, 'sawtooth', 1.0, 0.2); setTimeout(()=>playTone(100, 'sawtooth', 1.0, 0.2), 300); }

  /* --- VISUELS --- */
  const FACE_COUNT = 10;
  const tileImages = [null];
  for (let i = 1; i <= FACE_COUNT; i++) {
    const img = new Image();
    img.src = "visage" + i + ".jpg";
    tileImages[i] = img;
  }

  const colors = [
    null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF', '#555555'
  ];

  /* --- LOGIQUE --- */

  function createMatrix(w, h) {
    const m = [];
    for (let y = 0; y < h; y++) m.push(new Array(w).fill(0));
    return m;
  }

  function createPiece(type) {
    switch (type) {
      case 'T': return [[0,1,0],[1,1,1],[0,0,0]];
      case 'O': return [[2,2],[2,2]];
      case 'L': return [[0,0,3],[3,3,3],[0,0,0]]; 
      case 'J': return [[4,0,0],[4,4,4],[0,0,0]];
      case 'I': return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
      case 'S': return [[0,6,6],[6,6,0],[0,0,0]];
      case 'Z': return [[7,7,0],[0,7,7],[0,0,0]];
    }
    return [[1]];
  }

  let arena = createMatrix(COLS, ROWS);

  const player = {
    pos: {x:0, y:0},
    matrix: null,
    score: 0,
    level: 1,
  };

  function drawGrid() {
    ctx.strokeStyle = "rgba(0,0,0,0.1)";
    ctx.lineWidth = 2; 
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath(); ctx.moveTo(x*TILE, 0); ctx.lineTo(x*TILE, ROWS*TILE); ctx.stroke();
    }
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath(); ctx.moveTo(0, y*TILE); ctx.lineTo(COLS*TILE, y*TILE); ctx.stroke();
    }
  }

  function drawMatrix(matrix, offset, context = ctx, tileSize = TILE, outline = false) {
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          const px = (x + offset.x) * tileSize;
          const py = (y + offset.y) * tileSize;
           
          if (value === 99) {
             context.fillStyle = "#555";
             context.fillRect(px, py, tileSize, tileSize);
             context.strokeStyle = "#222";
             context.strokeRect(px, py, tileSize, tileSize);
             return;
          }

          const imgIndex = (value % FACE_COUNT) || 1; 
          const img = tileImages[imgIndex];

          if (img && img.complete && img.naturalWidth !== 0) {
            context.drawImage(img, px, py, tileSize, tileSize);
            if (outline) {
                context.strokeStyle = "rgba(0,0,0,0.5)";
                context.lineWidth = 2;
                context.strokeRect(px, py, tileSize, tileSize);
            }
          } else {
            context.fillStyle = colors[value % colors.length] || 'grey';
            context.fillRect(px, py, tileSize, tileSize);
            context.lineWidth = 3; 
            context.strokeStyle = 'rgba(255,255,255,0.4)';
            context.strokeRect(px+2, py+2, tileSize-4, tileSize-4);
            context.fillStyle = 'rgba(0,0,0,0.15)';
            context.fillRect(px+6, py+6, tileSize-12, tileSize-12);
          }
        }
      });
    });
  }

  function drawNextPiece() {
    if (!nextPieceMatrix) return;
    nextCtx.fillStyle = "#fff";
    nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
    
    const offsetX = (4 - nextPieceMatrix[0].length) / 2;
    const offsetY = (4 - nextPieceMatrix.length) / 2;
    
    drawMatrix(nextPieceMatrix, {x: offsetX, y: offsetY}, nextCtx, NEXT_TILE, false);
  }

  function merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          arena[y + player.pos.y][x + player.pos.x] = value;
        }
      });
    });
  }

  function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for (let y = 0; y < m.length; ++y) {
      for (let x = 0; x < m[y].length; ++x) {
        if (m[y][x] !== 0 &&
           (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  function arenaSweep() {
    let lines = 0;
    outer: for (let y = arena.length - 1; y > 0; --y) {
      for (let x = 0; x < arena[y].length; ++x) {
        if (arena[y][x] === 0) {
          continue outer;
        }
      }
      const row = arena.splice(y, 1)[0].fill(0);
      arena.unshift(row);
      ++y;
      lines++;
    }
    if (lines > 0) {
      sLine();
      const linePoints = [0, 40, 100, 300, 1200];
      player.score += linePoints[lines] * player.level;
      if (player.score > player.level * 1000) {
        player.level++;
        dropInterval = Math.max(100, 800 - (player.level * 50));
      }
      updateScore();
    }
  }

  function updateScore() {
    scoreElem.textContent = player.score;
    levelElem.textContent = player.level;
    
    // Mise à jour du grade
    const currentRank = getRankName(player.level);
    rankElem.textContent = currentRank;

    // Mise à jour Mobile
    mobScoreElem.textContent = "Score: " + player.score;
    mobLevelElem.textContent = "Niv: " + player.level;
    mobRankElem.textContent = currentRank;
  }

  function playerReset() {
    const pieces = 'ILJOTSZ';
    if (nextPieceMatrix === null) {
        nextPieceMatrix = createPiece(pieces[pieces.length * Math.random() | 0]);
    }
    player.matrix = nextPieceMatrix;
    nextPieceMatrix = createPiece(pieces[pieces.length * Math.random() | 0]);
    drawNextPiece();

    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

    if (collide(arena, player)) {
      handleGameOver();
    }
  }

  function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      sDrop();
      arenaSweep();
      playerReset();
    }
    dropCounter = 0;
  }

  function hardDrop() {
    while (!collide(arena, player)) {
      player.pos.y++;
    }
    player.pos.y--; 
    merge(arena, player);
    sDrop();
    arenaSweep();
    playerReset();
  }

  function playerRotate(dir) {
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while (collide(arena, player)) {
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if (offset > player.matrix[0].length) {
        rotate(player.matrix, -dir);
        player.pos.x = pos;
        return;
      }
    }
    sRotate();
  }

  function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
      for (let x = 0; x < y; ++x) {
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if (dir > 0) matrix.forEach(row => row.reverse());
    else matrix.reverse();
  }

  function draw() {
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    drawGrid();
    drawMatrix(arena, {x:0, y:0});

    if (gameState === "playing") {
      const ghost = {
        matrix: player.matrix,
        pos: {x: player.pos.x, y: player.pos.y}
      };
      while(!collide(arena, ghost)) {
        ghost.pos.y++;
      }
      ghost.pos.y--;
      
      ctx.globalAlpha = 0.2;
      drawMatrix(ghost.matrix, ghost.pos, ctx, TILE, false); 
      ctx.globalAlpha = 1;

      drawMatrix(player.matrix, player.pos, ctx, TILE, true);
    }
  }

  function update(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;

    if (gameState === "playing") {
      dropCounter += deltaTime;
      if (dropCounter > dropInterval) {
        playerDrop();
      }
    }

    draw();
    if (gameState !== "gameover") { 
        requestAnimationFrame(update);
    }
  }

  /* --- GAME OVER --- */
  function loadHighScores() {
    try { return JSON.parse(localStorage.getItem("tetris_scores") || "[]"); } catch { return []; }
  }
  function saveHighScores(list) {
    localStorage.setItem("tetris_scores", JSON.stringify(list));
  }
  function refreshHighScoreList() {
    const scores = loadHighScores();
    highscoreList.innerHTML = "";
    scores.forEach(s => {
      const li = document.createElement("li");
      li.textContent = `${s.name} : ${s.score}`;
      highscoreList.appendChild(li);
    });
  }

  function addHighScore(score) {
    setTimeout(() => {
        let name = prompt("GAME OVER ! \nGrade atteint : " + getRankName(player.level) + "\nTon pseudo :", "Etudiant CIEL");
        if (!name) return;
        name = name.trim().substring(0, 10);

        const scores = loadHighScores();
        scores.push({name, score});
        scores.sort((a,b)=>b.score-a.score);
        if (scores.length > 5) scores.length = 5; 
        saveHighScores(scores);
        refreshHighScoreList();
    }, 100); 
  }

  function handleGameOver() {
    gameState = "animating";
    sGameOver();
    messageCenter.textContent = "GAME OVER";

    let y = ROWS - 1;
    const animInterval = setInterval(() => {
        if (y < 0) {
            clearInterval(animInterval);
            addHighScore(player.score);
            gameState = "gameover";
            messageCenter.textContent = "GAME OVER — ESPACE POUR REJOUER";
            return;
        }
        arena[y].fill(99);
        draw(); 
        y--;
    }, 40);
  }

  function resetGame() {
    arena.forEach(row => row.fill(0));
    player.score = 0;
    player.level = 1;
    dropInterval = BASE_DROP;
    updateScore();
    nextPieceMatrix = null;
    playerReset();
    dropCounter = 0;
    gameState = "playing";
    messageCenter.textContent = "";
    sStart();
    requestAnimationFrame(update);
  }

  /* --- INPUTS --- */
  document.addEventListener("keydown", event => {
    if (!audioCtx) initAudioContext();

    if (event.code === "Space" && (gameState === "waiting" || gameState === "gameover")) {
        resetGame();
        return;
    }

    if (gameState === "playing") {
      switch(event.code) {
        case "ArrowLeft": 
        case "KeyQ": 
          player.pos.x--;
          if (collide(arena, player)) player.pos.x++; else sMove();
          break;
        case "ArrowRight": 
        case "KeyD":
          player.pos.x++;
          if (collide(arena, player)) player.pos.x--; else sMove();
          break;
        case "ArrowDown": 
        case "KeyS":
          playerDrop();
          break;
        case "ArrowUp": 
        case "KeyZ": 
           hardDrop();
           break;
        case "Space":
          playerRotate(1);
          break;
        case "KeyP":
          gameState = "paused";
          messageCenter.textContent = "PAUSE";
          break;
      }
    } else if (gameState === "paused" && event.code === "KeyP") {
        gameState = "playing";
        messageCenter.textContent = "";
    }
  });

  const setupMobileBtn = (id, action) => {
    const btn = document.getElementById(id);
    btn.addEventListener("touchstart", (e) => { e.preventDefault(); if(!audioCtx) initAudioContext(); action(); });
    btn.addEventListener("click", (e) => { if(!audioCtx) initAudioContext(); action(); });
  };

  setupMobileBtn("btn-left", () => { if(gameState==="playing") { player.pos.x--; if(collide(arena, player)) player.pos.x++; else sMove(); draw(); }});
  setupMobileBtn("btn-right", () => { if(gameState==="playing") { player.pos.x++; if(collide(arena, player)) player.pos.x--; else sMove(); draw(); }});
  setupMobileBtn("btn-down", () => { if(gameState==="playing") playerDrop(); draw(); });
  setupMobileBtn("btn-rotate", () => { if(gameState==="playing") playerRotate(1); draw(); });
  setupMobileBtn("btn-drop", () => { if(gameState==="playing") hardDrop(); draw(); });

  startBtn.addEventListener("click", () => { if(!audioCtx) initAudioContext(); resetGame(); });
  muteBtn.addEventListener("click", () => {
      muted = !muted;
      muteBtn.textContent = muted ? "Son : OFF" : "Son : ON";
      if(!muted && !audioCtx) initAudioContext();
  });

  refreshHighScoreList();
  updateScore(); // Affiche le grade initial
  draw(); 

</script>
</body>
</html>