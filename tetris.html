<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Tetris BTS CIEL - Lycée Simone Veil</title>

<style>
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    /* Empêche le rebond élastique sur iOS */
    overscroll-behavior: none;
  }

  body {
    background: url("fond_lycee.jpg") no-repeat center center fixed;
    background-color: #2c3e50; 
    background-size: cover;
    color: #000;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
  }

  #main {
    background: rgba(255,255,255,0.94); /* Légèrement plus opaque pour la lisibilité */
    border-radius: 16px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    box-sizing: border-box;
    box-shadow: 0 15px 35px rgba(0,0,0,0.6);
    width: 98%;
    height: 98%;
    max-width: 1000px;
    justify-content: center; 
    position: relative;
    z-index: 1;
    backdrop-filter: blur(5px); /* Effet verre dépoli moderne */
  }

  #header-group {
    text-align: center;
    margin-bottom: 5px;
  }

  #logo {
    width: 60px;
    height: auto;
    display: block;
    margin: 0 auto;
  }

  #title {
    font-size: 20px;
    font-weight: 900;
    color: #222;
    margin: 0;
    letter-spacing: -0.5px;
  }

  #subtitle {
    font-size: 11px;
    color: #555;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  #game-container {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    justify-content: center;
    height: 80vh; 
    width: 100%;
  }

  canvas#tetris {
    border: 4px solid #333;
    background: linear-gradient(180deg, #fff 0%, #f4f4f4 100%);
    display: block;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.1), 5px 5px 15px rgba(0,0,0,0.3);
    height: 100%; 
    width: auto; 
    aspect-ratio: 1/2;
    border-radius: 4px;
  }

  #side-panel {
    display: flex;
    flex-direction: column;
    gap: 8px;
    background: rgba(255,255,255,0.7);
    padding: 15px;
    border-radius: 10px;
    min-width: 180px;
    border: 2px solid #333;
    box-sizing: border-box;
    height: 100%;
    justify-content: center;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  }

  #next-piece-container {
    text-align: center;
    margin-bottom: 10px;
  }
  canvas#next {
    background: rgba(255,255,255,0.8);
    border: 2px solid #555;
    margin-top: 2px;
    width: 80px; 
    height: 80px;
    border-radius: 4px;
  }

  #score-box, #level-box {
    text-align: center;
    margin-bottom: 5px;
    background: rgba(255,255,255,0.5);
    padding: 5px;
    border-radius: 6px;
    border: 1px solid rgba(0,0,0,0.1);
  }

  .label-text {
    font-size: 11px;
    text-transform: uppercase;
    color: #666;
    font-weight: 800;
    letter-spacing: 0.5px;
  }

  #score {
    font-size: 22px;
    font-weight: 900;
    color: #2c3e50;
    font-variant-numeric: tabular-nums;
  }

  #level {
    font-size: 18px;
    font-weight: bold;
    color: #2c3e50;
  }
    
  #rank-name {
    font-size: 13px;
    font-weight: 900;
    color: #d32f2f;
    margin-top: 2px;
    min-height: 20px;
    line-height: 1.2;
  }

  #highscore-title {
    font-size: 13px;
    font-weight: bold;
    margin-top: 10px;
    text-decoration: underline;
    text-transform: uppercase;
  }

  #highscore-list {
    padding-left: 18px; 
    margin: 5px 0; 
    font-size: 13px;
    max-height: 120px;
    overflow-y: auto;
    font-family: monospace;
  }

  button {
    padding: 12px;
    border-radius: 6px;
    border: 2px solid #333;
    background: #fff;
    font-weight: bold;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.1s;
    margin-top: 5px;
    box-shadow: 0 2px 0 #333;
  }
  button:hover { background: #f0f0f0; transform: translateY(-1px); }
  button:active { background: #ccc; transform: translateY(2px); box-shadow: none; }
  button:focus { outline: none; }

  #controls-info {
    font-size: 10px;
    line-height: 1.4;
    margin-top: auto;
    color: #444;
    background: rgba(0,0,0,0.05);
    padding: 8px;
    border-radius: 4px;
    border: 1px dashed #999;
  }

  #message-center {
    font-size: 18px;
    font-weight: 900;
    text-align: center;
    color: #d32f2f;
    min-height: 24px;
    margin-top: 5px;
    text-shadow: 0 1px 0 rgba(255,255,255,0.8);
    animation: pulse 2s infinite;
  }
  @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; } 100% { opacity: 0.8; } }

  /* --- CONTRÔLES MOBILE --- */
  #mobile-controls {
    display: none;
    width: 100%;
    justify-content: space-between;
    margin-top: 5px;
    gap: 10px;
    padding-bottom: 5px;
    touch-action: none; /* Crucial pour le jeu mobile */
  }
    
  .pad-group {
    display: flex;
    gap: 12px;
  }

  .mob-btn {
    width: 58px;
    height: 58px;
    font-size: 24px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: linear-gradient(145deg, #ffffff, #e6e6e6);
    border: 2px solid #333;
    border-radius: 50%;
    box-shadow: 0 4px 0 #333;
    touch-action: manipulation;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  .mob-btn:active {
    transform: translateY(4px);
    box-shadow: none;
    background: #ddd;
  }
  .mob-btn.big {
    width: 68px;
    height: 68px;
    background: linear-gradient(145deg, #ffeba7, #ffdf80);
  }

  /* --- PROVISEUR + BULLE BD --- */
  #proviseur-box {
    position: absolute;
    left: calc(50% + 400px); 
    bottom: 10px;
    display: none;
    cursor: pointer;
    z-index: 10;
    transition: transform 0.3s ease-out;
  }
  #proviseur-box.pop-in {
    animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }
  @keyframes popIn { from { transform: scale(0) translateY(50px); } to { transform: scale(1) translateY(0); } }

  #proviseur-img {
    height: auto;
    max-height: 50vh;
    filter: drop-shadow(5px 5px 10px rgba(0,0,0,0.4));
  }

  #speech-bubble {
    position: absolute;
    left: 100%;
    bottom: 65%;
    margin-left: 12px;
    max-width: 320px;
    background: #fff;
    border-radius: 18px;
    border: 3px solid #333;
    padding: 12px 16px;
    font-size: 14px;
    font-weight: 700;
    color: #111;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    font-family: "Comic Sans MS", "Chalkboard SE", sans-serif; /* Style BD */
  }

  /* Flèche bulle PC */
  #speech-bubble::after {
    content: ""; position: absolute; right: 100%; bottom: 20%;
    border-width: 10px; border-style: solid;
    border-color: transparent #333 transparent transparent;
  }
  #speech-bubble::before {
    content: ""; position: absolute; right: 100%; bottom: 20%;
    margin-right: -4px; border-width: 8px; border-style: solid;
    border-color: transparent #fff transparent transparent;
    z-index: 2;
  }

  @media (max-width: 800px) {
    #main { 
        width: 100%; height: 100%; padding: 5px; border-radius: 0; justify-content: space-between;
    }
    #header-group { display: none; }
    #game-container { height: 60vh; align-items: center; width: 100%; gap: 5px; }
    #side-panel { display: none; } 
    #mobile-header { 
        display: flex; flex-direction: column; align-items: center; width: 95%; 
        font-weight: bold; font-size: 14px; margin-top: 5px;
        background: rgba(255,255,255,0.8); padding: 5px; border-radius: 8px;
        border: 1px solid rgba(0,0,0,0.1);
    }
    #mobile-header-row { display: flex; justify-content: space-between; width: 100%; }
    #mob-rank { color: #d32f2f; font-size: 12px; margin-top: 2px; font-weight: 900;}

    #mobile-controls { 
      display: flex; 
      padding: 0 10px 20px 10px; 
      box-sizing: border-box;
    }
    #message-center { font-size: 14px; margin-bottom: 5px; }

    /* --- PROVISEUR MOBILE --- */
    #proviseur-box {
      left: auto;
      right: 0px;
      bottom: 90px;
      top: auto;
      z-index: 20;
      pointer-events: none; /* Laisse passer les clics en dessous sur mobile */
    }
    #proviseur-img {
      height: 100px; 
      max-height: 20vh;
    }
    
    #speech-bubble {
      max-width: 180px;
      font-size: 12px;
      left: auto;
      right: 95%; 
      bottom: 20%;
      margin-left: 0;
      margin-right: 5px;
      white-space: normal;
      pointer-events: auto;
    }

    /* Flèche bulle Mobile */
    #speech-bubble::after {
      left: 100%; right: auto; bottom: 20%;
      border-color: transparent transparent transparent #333;
    }
    #speech-bubble::before {
      left: 100%; right: auto; bottom: 20%;
      margin-right: 0; margin-left: -4px;
      border-color: transparent transparent transparent #fff;
    }
  }
    
  @media (min-width: 801px) {
    #mobile-header { display: none; }
  }

</style>
</head>
<body>

<div id="main">

  <div id="header-group">
    <img id="logo" src="Logo.gif" alt="Logo BTS" onerror="this.style.display='none'"> 
    <div id="title">TETRIS – BTS CIEL</div>
    <div id="subtitle">Lycée Simone Veil - Noisiel</div>
  </div>

  <div id="mobile-header">
    <div id="mobile-header-row">
        <span id="mob-score">Score: 0</span>
        <span id="mob-level">Niv: 1</span>
    </div>
    <div id="mob-rank">Nouvelle Recrue</div>
  </div>

  <div id="game-container">
    <canvas id="tetris" width="800" height="1600"></canvas>

    <div id="side-panel">
      <div id="next-piece-container">
        <div style="font-weight:bold; margin-bottom:5px;">Suivante :</div>
        <canvas id="next" width="160" height="160"></canvas>
      </div>

      <div id="score-box">
        <div class="label-text">Score</div>
        <div id="score">0</div>
      </div>

      <div id="level-box">
        <div class="label-text">Niveau</div>
        <div id="level">1</div>
        <div id="rank-name">Nouvelle Recrue</div>
      </div>

      <div id="highscore-title">Meilleurs scores :</div>
      <ul id="highscore-list"></ul>

      <button id="start-btn">Recommencer</button>
      <button id="mute-btn">Son : ON</button>

      <div id="controls-info">
        <b>Contrôles :</b><br>
        ◀/▶/▼ : Bouger<br>
        ▲ : Hard Drop<br>
        Espace : Rotation<br>
        P : Pause
      </div>
    </div>
  </div>

  <div id="mobile-controls">
    <div class="pad-group">
      <button class="mob-btn" id="btn-left">◀</button>
      <button class="mob-btn" id="btn-down">▼</button>
      <button class="mob-btn" id="btn-right">▶</button>
    </div>
    <div class="pad-group">
      <button class="mob-btn big" id="btn-rotate">↻</button>
      <button class="mob-btn big" id="btn-drop">⤓</button>
    </div>
  </div>

  <div id="message-center">APPUYEZ SUR ESPACE POUR DÉMARRER</div>
</div>

<div id="proviseur-box">
  <img id="proviseur-img" src="proviseur.png" alt="Proviseur du lycée">
  <div id="speech-bubble"></div>
</div>

<script>
  /* --- INITIALISATION --- */
  const canvas = document.getElementById("tetris");
  const ctx = canvas.getContext("2d");
  const nextCanvas = document.getElementById("next");
  const nextCtx = nextCanvas.getContext("2d");
    
  // Optimisation rendu
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  nextCtx.imageSmoothingEnabled = true;

  const scoreElem = document.getElementById("score");
  const levelElem = document.getElementById("level");
  const rankElem = document.getElementById("rank-name");

  const mobScoreElem = document.getElementById("mob-score");
  const mobLevelElem = document.getElementById("mob-level");
  const mobRankElem = document.getElementById("mob-rank");

  const messageCenter = document.getElementById("message-center");
  const startBtn = document.getElementById("start-btn");
  const muteBtn = document.getElementById("mute-btn");
  const highscoreList = document.getElementById("highscore-list");

  /* --- GESTION PROVISEUR --- */
  const proviseurBox = document.getElementById("proviseur-box");
  const speechBubble = document.getElementById("speech-bubble");
  let proviseurTimeout = null;

  proviseurBox.addEventListener("click", () => hideProviseur());
  proviseurBox.addEventListener("touchstart", (e) => {
      e.preventDefault();
      hideProviseur();
  });

  function hideProviseur() {
      proviseurBox.classList.remove('pop-in');
      proviseurBox.style.display = "none";
  }

  const proviseurDialogues = {
    start: [
      "« Bienvenue en BTS CIEL. Essayez de faire mieux que vos bulletins. »",
      "« On s’échauffe : comme à la rentrée, mais avec moins de paperasse. »",
      "« Tetris CIEL : si vous ragez déjà, attendez l’épreuve E4. »"
    ],
    line: [
      "« Une ligne propre. Si seulement vos copies étaient aussi alignées. »",
      "« Pas mal. Continuez comme ça et je signe la mention. »",
      "« Une ligne en moins, un neurone en plus : bon calcul. »",
      "« C’est ce que j’appelle de la gestion de stock efficace. »"
    ],
    level: [
      "« Changement de niveau : comme le passage en 2e année ! »",
      "« Vous montez d’un cran. Gardez ce rythme au conseil de classe. »",
      "« Nouveau niveau. On va voir si vous tenez la cadence. »"
    ],
    gameover: [
      "« GAME OVER… mais au lycée, on n’a pas de bouton Recommencer. »",
      "« Conseil du proviseur : révisez la stratégie avant la prochaine partie. »",
      "« Ça, c’est ce qu’on appelle une commission d’appel ratée. »"
    ],
    generic: [
      "« Les CIEL, pensez à sauvegarder… vos neurones. »",
      "« Un Tetris bien rangé, c’est comme une salle serveur : ça respire. »",
      "« Pause ? Après avoir battu le highscore, pas avant. »"
    ]
  };

  function showProviseur(reason) {
    const pool = proviseurDialogues[reason] || proviseurDialogues.generic;
    const text = pool[Math.floor(Math.random() * pool.length)];
    speechBubble.textContent = text;
    proviseurBox.style.display = "block";
    proviseurBox.classList.add('pop-in');
    
    if (proviseurTimeout) clearTimeout(proviseurTimeout);
    proviseurTimeout = setTimeout(() => hideProviseur(), 5000);
  }

  // --- Constantes Jeu ---
  const COLS = 10;
  const ROWS = 20;
  const TILE = 80; 
  const NEXT_TILE = 40; 
  const BASE_DROP = 800;

  let gameState = "waiting"; 
  let dropInterval = BASE_DROP;
  let dropCounter = 0;
  let lastTime = 0;
  let nextPieceMatrix = null; 

  let muted = false;
  let audioCtx = null;

  if(localStorage.getItem("tetris_muted") === "true") {
      muted = true;
      muteBtn.textContent = "Son : OFF";
  }

  const cielRanks = [
      "Nouvelle Recrue", "Apprenti Câbleur", "Scripteur Bash", "Décodeur Binaire",
      "Admin Réseau", "Développeur C++", "Survivant de l'E4", "Expert Cybersécu",
      "Chef de Projet E6", "Major de Promo", "Diplômé CIEL", "Légende du Lycée"
  ];

  function getRankName(level) {
      if (level > cielRanks.length) return cielRanks[cielRanks.length - 1];
      return cielRanks[level - 1];
  }

  /* --- AUDIO --- */
  function initAudioContext() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) audioCtx = new AC();
    }
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }

  function playTone(freq, type, duration, vol) {
    if (muted || !audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  }

  function sStart()  { playTone(440, 'triangle', 0.5, 0.1); setTimeout(()=>playTone(880, 'triangle', 0.5, 0.1), 100); }
  function sMove()   { playTone(200, 'sine', 0.1, 0.05); }
  function sRotate() { playTone(300, 'square', 0.1, 0.05); }
  function sDrop()   { playTone(100, 'sawtooth', 0.2, 0.08); }
  function sLine()   { playTone(600, 'sine', 0.2, 0.1); setTimeout(()=>playTone(1200, 'sine', 0.4, 0.1), 100); }
  function sGameOver(){ playTone(150, 'sawtooth', 1.0, 0.2); setTimeout(()=>playTone(100, 'sawtooth', 1.0, 0.2), 300); }

  /* --- VISUELS --- */
  const FACE_COUNT = 11; 
  const tileImages = [null];
  for (let i = 1; i <= FACE_COUNT; i++) {
    const img = new Image();
    img.src = "visage" + i + ".jpg";
    tileImages[i] = img;
  }

  // Couleurs améliorées pour le mode sans image
  const colors = [
    null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF', '#555555'
  ];

  /* --- LOGIQUE PARTICULES (Effet "Juice") --- */
  let particles = [];
  
  function spawnParticles(x, y, color, amount = 10) {
    for (let i = 0; i < amount; i++) {
      particles.push({
        x: x + TILE / 2,
        y: y + TILE / 2,
        vx: (Math.random() - 0.5) * 15,
        vy: (Math.random() - 0.5) * 15,
        life: 1.0,
        color: color,
        size: Math.random() * 8 + 4
      });
    }
  }

  function updateAndDrawParticles(ctx) {
    for (let i = particles.length - 1; i >= 0; i--) {
      let p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.5; // Gravité
      p.life -= 0.03;
      
      if (p.life <= 0) {
        particles.splice(i, 1);
        continue;
      }
      
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
      ctx.globalAlpha = 1.0;
    }
  }

  /* --- LOGIQUE TETRIS --- */
  function createMatrix(w, h) {
    const m = [];
    for (let y = 0; y < h; y++) m.push(new Array(w).fill(0));
    return m;
  }

  function createPiece(type) {
    const id = 1 + (Math.random() * FACE_COUNT | 0);
    // On stocke le type pour la couleur de fallback
    let shape = [];
    switch (type) {
      case 'T': shape = [[0, id, 0],[id, id, id],[0, 0, 0]]; break;
      case 'O': shape = [[id, id],[id, id]]; break;
      case 'L': shape = [[0, 0, id],[id, id, id],[0, 0, 0]]; break;
      case 'J': shape = [[id, 0, 0],[id, id, id],[0, 0, 0]]; break;
      case 'I': shape = [[0, id, 0, 0],[0, id, 0, 0],[0, id, 0, 0],[0, id, 0, 0]]; break;
      case 'S': shape = [[0, id, id],[id, id, 0],[0, 0, 0]]; break;
      case 'Z': shape = [[id, id, 0],[0, id, id],[0, 0, 0]]; break;
    }
    // Petite astuce: on attache la "couleur" (index 1-7) à la matrice pour le rendu fallback
    shape.typeIdx = "ILJOTSZ".indexOf(type) + 1; 
    return shape;
  }

  let arena = createMatrix(COLS, ROWS);

  const player = {
    pos: {x:0, y:0},
    matrix: null,
    score: 0,
    level: 1,
  };

  let flashPhase = 0; 

  function drawGrid() {
    ctx.strokeStyle = "rgba(0, 0, 0, 0.08)";
    ctx.lineWidth = 1; 
    
    for (let x = 1; x < COLS; x++) {
      ctx.beginPath(); ctx.moveTo(x*TILE, 0); ctx.lineTo(x*TILE, ROWS*TILE); ctx.stroke();
    }
    for (let y = 1; y < ROWS; y++) {
      ctx.beginPath(); ctx.moveTo(0, y*TILE); ctx.lineTo(COLS*TILE, y*TILE); ctx.stroke();
    }
  }

  // Helper pour dessiner un bloc joli même sans image
  function drawBeveledRect(ctx, x, y, size, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x, y, size, size);
      
      // Relief (Bevel)
      ctx.lineWidth = size / 8;
      ctx.strokeStyle = "rgba(255,255,255,0.4)";
      ctx.beginPath(); ctx.moveTo(x, y+size); ctx.lineTo(x, y); ctx.lineTo(x+size, y); ctx.stroke();
      
      ctx.strokeStyle = "rgba(0,0,0,0.3)";
      ctx.beginPath(); ctx.moveTo(x+size, y); ctx.lineTo(x+size, y+size); ctx.lineTo(x, y+size); ctx.stroke();
      
      // Centre glossy
      ctx.fillStyle = "rgba(255,255,255,0.1)";
      ctx.fillRect(x + size/4, y + size/4, size/2, size/2);
  }

  function drawMatrix(matrix, offset, context = ctx, tileSize = TILE) {
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          const px = (x + offset.x) * tileSize;
          const py = (y + offset.y) * tileSize;

          // Animation suppression (valeur 99)
          if (value === 99) {
            const progress = flashPhase / 10; 
            const scale = 1 - progress; 
            const center = tileSize / 2;
            
            context.save();
            context.translate(px + center, py + center);
            context.scale(scale, scale);
            context.fillStyle = "#fff"; 
            context.fillRect(-center, -center, tileSize, tileSize);
            context.restore();
            return;
          }

          const imgIndex = ((value - 1 + FACE_COUNT) % FACE_COUNT) + 1;
          const img = tileImages[imgIndex];

          // Choix de la couleur de repli (basé sur le type de pièce ou aléatoire si fixe)
          const fallbackColor = colors[(matrix.typeIdx || (value % 7) + 1)] || '#888';

          if (img && img.complete && img.naturalWidth !== 0) {
            context.drawImage(img, px, py, tileSize, tileSize);
            // Petit effet de vitre
            context.fillStyle = "rgba(255,255,255,0.1)";
            context.fillRect(px, py, tileSize, tileSize/2);
            context.strokeStyle = "rgba(0,0,0,0.2)";
            context.strokeRect(px, py, tileSize, tileSize);
          } else {
            // Dessin vectoriel joli si pas d'image
            drawBeveledRect(context, px, py, tileSize, fallbackColor);
          }
        }
      });
    });
  }

  function drawNextPiece() {
    if (!nextPieceMatrix) return;
    // Fond propre
    nextCtx.clearRect(0,0, nextCanvas.width, nextCanvas.height);
    
    const offsetX = (4 - nextPieceMatrix[0].length) / 2;
    const offsetY = (4 - nextPieceMatrix.length) / 2;
    
    drawMatrix(nextPieceMatrix, {x: offsetX, y: offsetY}, nextCtx, NEXT_TILE);
  }

  function merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          arena[y + player.pos.y][x + player.pos.x] = value;
        }
      });
    });
  }

  function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for (let y = 0; y < m.length; ++y) {
      for (let x = 0; x < m[y].length; ++x) {
        if (m[y][x] !== 0 &&
           (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  function arenaSweep() {
    if (gameState === "lineflash" || gameState === "animating") return;

    const rowsToClear = [];
    for (let y = arena.length - 1; y >= 0; --y) {
      let full = true;
      for (let x = 0; x < arena[y].length; ++x) {
        if (arena[y][x] === 0) { full = false; break; }
      }
      if (full) rowsToClear.push(y);
    }

    if (rowsToClear.length === 0) {
      if (Math.random() < 0.05) showProviseur("generic");
      return;
    }

    gameState = "lineflash";
    rowsToClear.forEach(y => {
        // Effet particule sur toute la ligne
        for(let x=0; x<COLS; x++) {
             // On tente de récupérer la couleur pour les particules
            spawnParticles(x*TILE, y*TILE, '#FFF', 3);
        }
        arena[y].fill(99);
    });

    let frame = 0;
    const flashInterval = setInterval(() => {
      frame++;
      flashPhase = frame; 
      draw(); 

      if (frame >= 8) {
        clearInterval(flashInterval);
        rowsToClear.sort((a, b) => b - a);
        rowsToClear.forEach(y => arena.splice(y, 1));
        while (arena.length < ROWS) arena.unshift(new Array(COLS).fill(0));

        const lines = rowsToClear.length;
        sLine();
        const linePoints = [0, 40, 100, 300, 1200];
        player.score += (linePoints[lines] || 1200) * player.level;

        if (player.score > player.level * 1000) {
          player.level++;
          dropInterval = Math.max(100, 800 - (player.level * 50));
          showProviseur("level");
        } else if (Math.random() < 0.5) {
          showProviseur("line");
        }

        updateScore();
        gameState = "playing";
        draw(); 
      }
    }, 40);
  }

  function updateScore() {
    scoreElem.textContent = player.score;
    levelElem.textContent = player.level;
    const currentRank = getRankName(player.level);
    rankElem.textContent = currentRank;
    mobScoreElem.textContent = "Score: " + player.score;
    mobLevelElem.textContent = "Niv: " + player.level;
    mobRankElem.textContent = currentRank;
  }

  function playerReset() {
    const pieces = 'ILJOTSZ';
    if (nextPieceMatrix === null) {
        nextPieceMatrix = createPiece(pieces[pieces.length * Math.random() | 0]);
    }
    player.matrix = nextPieceMatrix;
    nextPieceMatrix = createPiece(pieces[pieces.length * Math.random() | 0]);
    drawNextPiece();

    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

    if (collide(arena, player)) {
      handleGameOver();
    }
  }

  function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      sDrop();
      // Petite particule d'atterrissage
      player.matrix.forEach((row, y) => row.forEach((v, x) => {
          if(v) spawnParticles((player.pos.x+x)*TILE, (player.pos.y+y)*TILE, "#ddd", 2);
      }));
      
      arenaSweep();
      playerReset();
    }
    dropCounter = 0;
  }

  function hardDrop() {
    let droppedDist = 0;
    while (!collide(arena, player)) {
      player.pos.y++;
      droppedDist++;
    }
    player.pos.y--; 
    merge(arena, player);
    sDrop();
    
    // Grosse particule pour Hard Drop
    player.matrix.forEach((row, y) => row.forEach((v, x) => {
          if(v) spawnParticles((player.pos.x+x)*TILE, (player.pos.y+y)*TILE, "#fff", 5);
    }));

    arenaSweep();
    playerReset();
  }

  function playerRotate(dir) {
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while (collide(arena, player)) {
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if (offset > player.matrix[0].length) {
        rotate(player.matrix, -dir);
        player.pos.x = pos;
        return;
      }
    }
    sRotate();
  }

  function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
      for (let x = 0; x < y; ++x) {
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if (dir > 0) matrix.forEach(row => row.reverse());
    else matrix.reverse();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawGrid();
    drawMatrix(arena, {x:0, y:0}); 
    updateAndDrawParticles(ctx);

    if (gameState === "playing" || gameState === "lineflash") {
      // GHOST PIECE
      const ghost = {
        matrix: player.matrix,
        pos: {x: player.pos.x, y: player.pos.y}
      };
      while (!collide(arena, ghost)) {
        ghost.pos.y++;
      }
      ghost.pos.y--;
      
      ctx.save();
      ctx.globalAlpha = 0.2;
      // Dessin du fantôme en couleur unie
      const ghostColor = colors[player.matrix.typeIdx || 1];
      ghost.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
             ctx.fillStyle = ghostColor;
             ctx.fillRect((x + ghost.pos.x) * TILE, (y + ghost.pos.y) * TILE, TILE, TILE);
             ctx.strokeStyle = "#000";
             ctx.strokeRect((x + ghost.pos.x) * TILE, (y + ghost.pos.y) * TILE, TILE, TILE);
          }
        });
      });
      ctx.restore();

      // JOUEUR
      drawMatrix(player.matrix, player.pos, ctx, TILE);
    }
  }

  function update(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;

    if (gameState === "playing") {
      dropCounter += deltaTime;
      if (dropCounter > dropInterval) {
        playerDrop();
      }
    }

    draw();
    if (gameState !== "gameover") { 
        requestAnimationFrame(update);
    }
  }

  /* --- GAME OVER --- */
  function loadHighScores() {
    try { return JSON.parse(localStorage.getItem("tetris_scores") || "[]"); } catch { return []; }
  }
  function saveHighScores(list) {
    localStorage.setItem("tetris_scores", JSON.stringify(list));
  }
  function refreshHighScoreList() {
    const scores = loadHighScores();
    highscoreList.innerHTML = "";
    scores.forEach(s => {
      const li = document.createElement("li");
      li.textContent = `${s.name} : ${s.score}`;
      highscoreList.appendChild(li);
    });
  }

  function addHighScore(score) {
    // Petit délai pour laisser l'animation finir
    setTimeout(() => {
        let name = prompt("GAME OVER !\nGrade : " + getRankName(player.level) + "\nPseudo :", "Etudiant CIEL");
        if (!name) name = "Anonyme";
        name = name.trim().substring(0, 10);

        const scores = loadHighScores();
        scores.push({name, score});
        scores.sort((a,b)=>b.score-a.score);
        if (scores.length > 5) scores.length = 5; 
        saveHighScores(scores);
        refreshHighScoreList();
    }, 100); 
  }

  function handleGameOver() {
    gameState = "animating";
    sGameOver();
    messageCenter.textContent = "GAME OVER";
    showProviseur("gameover");

    // Animation rideau
    let y = ROWS - 1;
    const animInterval = setInterval(() => {
        if (y < 0) {
            clearInterval(animInterval);
            addHighScore(player.score);
            gameState = "gameover";
            messageCenter.textContent = "GAME OVER — ESPACE POUR REJOUER";
            return;
        }
        arena[y].fill(99); // 99 = bloc blanc flash
        flashPhase = 5; 
        draw(); 
        y--;
    }, 30);
  }

  function resetGame() {
    arena.forEach(row => row.fill(0));
    player.score = 0;
    player.level = 1;
    dropInterval = BASE_DROP;
    particles = [];
    updateScore();
    nextPieceMatrix = null;
    playerReset();
    dropCounter = 0;
    gameState = "playing";
    messageCenter.textContent = "";
    sStart();
    showProviseur("start");
    requestAnimationFrame(update);
  }

  /* --- INPUTS --- */
  document.addEventListener("keydown", event => {
    if (!audioCtx) initAudioContext();

    if (event.code === "Space" && (gameState === "waiting" || gameState === "gameover")) {
        resetGame();
        return;
    }

    if (gameState === "playing") {
      switch(event.code) {
        case "ArrowLeft": 
        case "KeyQ": 
          player.pos.x--;
          if (collide(arena, player)) player.pos.x++; else sMove();
          break;
        case "ArrowRight": 
        case "KeyD":
          player.pos.x++;
          if (collide(arena, player)) player.pos.x--; else sMove();
          break;
        case "ArrowDown": 
        case "KeyS":
          playerDrop();
          break;
        case "ArrowUp": 
        case "KeyZ": 
           hardDrop();
           break;
        case "Space":
          playerRotate(1);
          break;
        case "KeyP":
          gameState = "paused";
          messageCenter.textContent = "PAUSE";
          break;
      }
    } else if (gameState === "paused" && event.code === "KeyP") {
        gameState = "playing";
        messageCenter.textContent = "";
    }
  });

  const setupMobileBtn = (id, action) => {
    const btn = document.getElementById(id);
    // Prevents double tap zoom & scroll
    btn.addEventListener("touchstart", (e) => { 
        e.preventDefault(); 
        if(!audioCtx) initAudioContext(); 
        action(); 
    }, {passive: false});
    // Fallback click
    btn.addEventListener("click", (e) => { 
        if(!audioCtx) initAudioContext(); 
        action(); 
    });
  };

  setupMobileBtn("btn-left", () => { if(gameState==="playing") { player.pos.x--; if(collide(arena, player)) player.pos.x++; else sMove(); draw(); }});
  setupMobileBtn("btn-right", () => { if(gameState==="playing") { player.pos.x++; if(collide(arena, player)) player.pos.x--; else sMove(); draw(); }});
  setupMobileBtn("btn-down", () => { if(gameState==="playing") playerDrop(); draw(); });
  setupMobileBtn("btn-rotate", () => { if(gameState==="playing") playerRotate(1); draw(); });
  setupMobileBtn("btn-drop", () => { if(gameState==="playing") hardDrop(); draw(); });

  startBtn.addEventListener("click", () => {
      startBtn.blur();
      if(!audioCtx) initAudioContext();
      resetGame();
  });

  muteBtn.addEventListener("click", () => {
      muteBtn.blur();
      muted = !muted;
      muteBtn.textContent = muted ? "Son : OFF" : "Son : ON";
      localStorage.setItem("tetris_muted", muted); 
      if(!muted && !audioCtx) initAudioContext();
  });

  refreshHighScoreList();
  updateScore();
  draw(); 

  // Tap n'importe où sur le canvas pour démarrer sur mobile
  canvas.addEventListener("touchstart", (e) => {
      if(e.target === canvas) e.preventDefault();
      if (!audioCtx) initAudioContext();
      if (gameState === "waiting" || gameState === "gameover") {
          resetGame();
      }
  }, {passive: false});

</script>
</body>
</html>