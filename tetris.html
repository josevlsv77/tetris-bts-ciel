<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Tetris BTS CIEL - Ultimate</title>

<style>
  html, body {
    height: 100%;
    margin: 0;
    overflow: hidden; /* Empêche le scroll sur mobile */
  }

  body {
    /* Fond : si l'image n'est pas là, on met un dégradé sympa */
    background: url("fond_lycee.jpg") no-repeat center center fixed;
    background-color: #2c3e50; 
    background-size: cover;
    color: #000;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    display: flex;
    justify-content: center;
    align-items: center; /* Centré verticalement */
    padding: 10px;
    box-sizing: border-box;
  }

  #main {
    background: rgba(255,255,255,0.92);
    border-radius: 16px;
    padding: 15px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    box-sizing: border-box;
    box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    max-height: 100vh;
  }

  #header-group {
    text-align: center;
  }

  #logo {
    width: 80px; /* Un peu plus petit pour gagner de la place */
    height: auto;
    display: block;
    margin: 0 auto;
  }

  #title {
    font-size: 24px;
    font-weight: 900;
    color: #222;
    margin: 5px 0 0 0;
  }

  #subtitle {
    font-size: 12px;
    color: #555;
    font-weight: 600;
  }

  #game-container {
    display: flex;
    gap: 15px;
    align-items: flex-start;
  }

  /* Canvas principal */
  canvas#tetris {
    border: 3px solid #333;
    background: #fff;
    display: block;
    box-shadow: 5px 5px 15px rgba(0,0,0,0.2);
    /* Responsive simple */
    max-height: 65vh; 
    width: auto;
    aspect-ratio: 1/2;
  }

  #side-panel {
    display: flex;
    flex-direction: column;
    gap: 8px;
    background: rgba(255,255,255,0.6);
    padding: 10px;
    border-radius: 10px;
    min-width: 160px;
    border: 2px solid #333;
    box-sizing: border-box;
  }

  /* Prévisualisation */
  #next-piece-container {
    text-align: center;
    margin-bottom: 5px;
  }
  canvas#next {
    background: #fff;
    border: 2px solid #555;
    margin-top: 2px;
  }

  #score, #level {
    font-size: 16px;
    font-weight: bold;
    color: #000;
  }

  #highscore-title {
    font-size: 13px;
    font-weight: bold;
    margin-top: 5px;
    text-decoration: underline;
  }

  #highscore-list {
    padding-left: 18px; 
    margin: 2px 0; 
    font-size: 12px;
    max-height: 100px;
    overflow-y: auto;
  }

  button {
    padding: 8px;
    border-radius: 6px;
    border: 2px solid #333;
    background: #fff;
    font-weight: bold;
    font-size: 12px;
    cursor: pointer;
    transition: background 0.2s;
  }
  button:hover { background: #eee; }
  button:active { background: #ccc; }

  #controls-info {
    font-size: 10px;
    line-height: 1.3;
    margin-top: 5px;
    color: #444;
  }

  #message-center {
    font-size: 16px;
    font-weight: 900;
    text-align: center;
    color: #d32f2f;
    min-height: 20px;
  }

  /* --- CONTRÔLES MOBILE --- */
  #mobile-controls {
    display: none; /* Caché par défaut */
    width: 100%;
    justify-content: space-between;
    margin-top: 5px;
    gap: 10px;
  }
  
  .pad-group {
    display: flex;
    gap: 8px;
  }

  .mob-btn {
    width: 48px;
    height: 48px;
    font-size: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(255,255,255,0.9);
    border: 2px solid #333;
    border-radius: 8px;
    box-shadow: 0 4px 0 #333;
    touch-action: manipulation; /* Améliore la réactivité tactile */
    user-select: none;
  }
  .mob-btn:active {
    transform: translateY(4px);
    box-shadow: none;
    background: #ddd;
  }
  .mob-btn.big {
    width: 55px;
    height: 55px;
    background: #ffeba7;
  }

  /* RESPONSIVE : Adaptation Mobile */
  @media (max-width: 800px) {
    body { align-items: flex-start; }
    #main { padding: 10px; width: 100%; max-width: 400px; }
    #game-container { width: 100%; justify-content: center; }
    #side-panel { display: none; } /* On cache le panneau latéral sur mobile pour la place */
    
    /* On affiche une version mini du score en haut */
    #mobile-header { display: flex; justify-content: space-between; width: 100%; font-weight: bold; font-size: 14px; margin-bottom: 5px;}
    
    #mobile-controls { display: flex; }
    #logo { width: 40px; }
    #title { font-size: 18px; }
    #subtitle { display: none; }
    #controls-info { display: none; }
  }
  @media (min-width: 801px) {
    #mobile-header { display: none; }
  }

</style>
</head>
<body>

<div id="main">

  <div id="header-group">
    <img id="logo" src="Logo.gif" alt="Logo BTS" onerror="this.style.display='none'">
    <div id="title">TETRIS – BTS CIEL</div>
    <div id="subtitle">Valide tes modules pour avoir ton diplôme !</div>
  </div>

  <div id="mobile-header">
    <span id="mob-score">Score: 0</span>
    <span id="mob-level">Niv: 1</span>
  </div>

  <div id="game-container">
    <canvas id="tetris" width="400" height="800"></canvas>

    <div id="side-panel">
      <div id="next-piece-container">
        <div>Suivante :</div>
        <canvas id="next" width="80" height="80"></canvas>
      </div>

      <div id="score">Score : 0</div>
      <div id="level">Niveau : 1</div>

      <div id="highscore-title">Meilleurs scores :</div>
      <ul id="highscore-list"></ul>

      <button id="start-btn">Recommencer</button>
      <button id="mute-btn">Son : ON</button>

      <div id="controls-info">
        <b>Clavier :</b><br>
        ◀/▶/▼ : Bouger<br>
        ▲ : Hard Drop<br>
        Espace : Rotation<br>
        P : Pause
      </div>
    </div>
  </div>

  <div id="mobile-controls">
    <div class="pad-group">
      <button class="mob-btn" id="btn-left">◀</button>
      <button class="mob-btn" id="btn-down">▼</button>
      <button class="mob-btn" id="btn-right">▶</button>
    </div>
    <div class="pad-group">
      <button class="mob-btn big" id="btn-rotate">↻</button>
      <button class="mob-btn big" id="btn-drop">⤓</button>
    </div>
  </div>

  <div id="message-center">APPUYEZ SUR ESPACE POUR DÉMARRER</div>
</div>

<script>
  /* --- INITIALISATION --- */
  const canvas = document.getElementById("tetris");
  const ctx = canvas.getContext("2d");
  const nextCanvas = document.getElementById("next");
  const nextCtx = nextCanvas.getContext("2d");
  
  // Optimisation affichage
  ctx.imageSmoothingEnabled = false;
  nextCtx.imageSmoothingEnabled = false;

  // Éléments UI
  const scoreElem = document.getElementById("score");
  const levelElem = document.getElementById("level");
  const mobScoreElem = document.getElementById("mob-score");
  const mobLevelElem = document.getElementById("mob-level");
  const messageCenter = document.getElementById("message-center");
  const startBtn = document.getElementById("start-btn");
  const muteBtn = document.getElementById("mute-btn");
  const highscoreList = document.getElementById("highscore-list");

  // Constantes Jeu
  const COLS = 10;
  const ROWS = 20;
  const TILE = 40;
  const NEXT_TILE = 20; // Taille plus petite pour la preview
  const BASE_DROP = 800;

  // Variables État
  let gameState = "waiting"; // waiting, playing, paused, gameover, animating
  let dropInterval = BASE_DROP;
  let dropCounter = 0;
  let lastTime = 0;
  let nextPieceMatrix = null; // Stocke la pièce suivante

  // Audio
  let muted = false;
  let audioCtx = null;

  /* --- AUDIO --- */
  function initAudioContext() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) audioCtx = new AC();
    }
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }

  function playTone(freq, type, duration, vol) {
    if (muted || !audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  }

  // Sons synthétisés (pas besoin de fichiers)
  function sStart()  { playTone(440, 'triangle', 0.5, 0.1); setTimeout(()=>playTone(880, 'triangle', 0.5, 0.1), 100); }
  function sMove()   { playTone(200, 'sine', 0.1, 0.05); }
  function sRotate() { playTone(300, 'square', 0.1, 0.05); }
  function sDrop()   { playTone(100, 'sawtooth', 0.2, 0.08); }
  function sLine()   { playTone(600, 'sine', 0.2, 0.1); setTimeout(()=>playTone(1200, 'sine', 0.4, 0.1), 100); }
  function sGameOver(){ playTone(150, 'sawtooth', 1.0, 0.2); setTimeout(()=>playTone(100, 'sawtooth', 1.0, 0.2), 300); }

  /* --- VISUELS & IMAGES --- */
  const FACE_COUNT = 10;
  const tileImages = [null];
  for (let i = 1; i <= FACE_COUNT; i++) {
    const img = new Image();
    img.src = "visage" + i + ".jpg"; // Assure-toi que ces fichiers existent
    tileImages[i] = img;
  }

  // Palette de secours (Fallback Colors style Tetris officiel)
  const colors = [
    null,
    '#FF0D72', // T (Magenta)
    '#0DC2FF', // I (Cyan)
    '#0DFF72', // S (Vert)
    '#F538FF', // Z (Violet)
    '#FF8E0D', // L (Orange)
    '#FFE138', // O (Jaune)
    '#3877FF', // J (Bleu)
    '#555555', // Gris foncé (Game Over)
  ];

  /* --- LOGIQUE DU JEU --- */

  function createMatrix(w, h) {
    const m = [];
    for (let y = 0; y < h; y++) m.push(new Array(w).fill(0));
    return m;
  }

  function createPiece(type) {
    // Formes officielles
    switch (type) {
      case 'T': return [[0,1,0],[1,1,1],[0,0,0]];
      case 'O': return [[2,2],[2,2]];
      case 'L': return [[0,0,3],[3,3,3],[0,0,0]]; // Modif indice pour couleur diff
      case 'J': return [[4,0,0],[4,4,4],[0,0,0]];
      case 'I': return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
      case 'S': return [[0,6,6],[6,6,0],[0,0,0]];
      case 'Z': return [[7,7,0],[0,7,7],[0,0,0]];
    }
    return [[1]];
  }

  let arena = createMatrix(COLS, ROWS);

  const player = {
    pos: {x:0, y:0},
    matrix: null,
    score: 0,
    level: 1,
  };

  function drawGrid() {
    ctx.strokeStyle = "rgba(0,0,0,0.1)";
    ctx.lineWidth = 1;
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath(); ctx.moveTo(x*TILE, 0); ctx.lineTo(x*TILE, ROWS*TILE); ctx.stroke();
    }
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath(); ctx.moveTo(0, y*TILE); ctx.lineTo(COLS*TILE, y*TILE); ctx.stroke();
    }
  }

  // Fonction de dessin améliorée (gère images OU couleurs)
  function drawMatrix(matrix, offset, context = ctx, tileSize = TILE, outline = false) {
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          const px = (x + offset.x) * tileSize;
          const py = (y + offset.y) * tileSize;
          
          // Animation de Game Over (Gris)
          if (value === 99) {
             context.fillStyle = "#555";
             context.fillRect(px, py, tileSize, tileSize);
             context.strokeStyle = "#222";
             context.strokeRect(px, py, tileSize, tileSize);
             return;
          }

          // Tentative affichage Image
          // On utilise modulo pour assigner une image même si value > FACE_COUNT
          const imgIndex = (value % FACE_COUNT) || 1; 
          const img = tileImages[imgIndex];

          if (img && img.complete && img.naturalWidth !== 0) {
            context.drawImage(img, px, py, tileSize, tileSize);
            if (outline) {
                context.strokeStyle = "rgba(0,0,0,0.5)";
                context.lineWidth = 1;
                context.strokeRect(px, py, tileSize, tileSize);
            }
          } else {
            // FALLBACK COULEUR
            context.fillStyle = colors[value % colors.length] || 'grey';
            
            // Effet "biseau" 3D simple
            context.fillRect(px, py, tileSize, tileSize);
            context.lineWidth = 2;
            context.strokeStyle = 'rgba(255,255,255,0.4)';
            context.strokeRect(px+2, py+2, tileSize-4, tileSize-4);
            
            context.fillStyle = 'rgba(0,0,0,0.15)';
            context.fillRect(px+4, py+4, tileSize-8, tileSize-8);
          }
        }
      });
    });
  }

  function drawNextPiece() {
    if (!nextPieceMatrix) return;
    nextCtx.fillStyle = "#fff";
    nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
    
    // Centrage
    const offsetX = (4 - nextPieceMatrix[0].length) / 2;
    const offsetY = (4 - nextPieceMatrix.length) / 2;
    
    drawMatrix(nextPieceMatrix, {x: offsetX, y: offsetY}, nextCtx, NEXT_TILE, false);
  }

  function merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          arena[y + player.pos.y][x + player.pos.x] = value;
        }
      });
    });
  }

  function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for (let y = 0; y < m.length; ++y) {
      for (let x = 0; x < m[y].length; ++x) {
        if (m[y][x] !== 0 &&
           (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  function arenaSweep() {
    let lines = 0;
    outer: for (let y = arena.length - 1; y > 0; --y) {
      for (let x = 0; x < arena[y].length; ++x) {
        if (arena[y][x] === 0) {
          continue outer;
        }
      }
      const row = arena.splice(y, 1)[0].fill(0);
      arena.unshift(row);
      ++y;
      lines++;
    }
    if (lines > 0) {
      sLine();
      // Score classique Nintendo
      const linePoints = [0, 40, 100, 300, 1200];
      player.score += linePoints[lines] * player.level;
      
      if (player.score > player.level * 1000) {
        player.level++;
        dropInterval = Math.max(100, 800 - (player.level * 50));
      }
      updateScore();
    }
  }

  function updateScore() {
    const txtScore = "Score : " + player.score;
    const txtLevel = "Niveau : " + player.level;
    scoreElem.textContent = txtScore;
    levelElem.textContent = txtLevel;
    
    // Mise à jour mobile
    mobScoreElem.textContent = "Score: " + player.score;
    mobLevelElem.textContent = "Niv: " + player.level;
  }

  function playerReset() {
    const pieces = 'ILJOTSZ';
    
    // Si c'est la toute première pièce
    if (nextPieceMatrix === null) {
        nextPieceMatrix = createPiece(pieces[pieces.length * Math.random() | 0]);
    }

    player.matrix = nextPieceMatrix;
    
    // Générer la suivante
    nextPieceMatrix = createPiece(pieces[pieces.length * Math.random() | 0]);
    drawNextPiece();

    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

    if (collide(arena, player)) {
      handleGameOver();
    }
  }

  function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      sDrop();
      arenaSweep();
      playerReset();
    }
    dropCounter = 0;
  }

  function hardDrop() {
    while (!collide(arena, player)) {
      player.pos.y++;
    }
    player.pos.y--; // Remonter d'un cran car on est rentré dans le sol
    merge(arena, player);
    sDrop();
    arenaSweep();
    playerReset();
  }

  function playerRotate(dir) {
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while (collide(arena, player)) {
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if (offset > player.matrix[0].length) {
        rotate(player.matrix, -dir);
        player.pos.x = pos;
        return;
      }
    }
    sRotate();
  }

  function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
      for (let x = 0; x < y; ++x) {
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if (dir > 0) {
      matrix.forEach(row => row.reverse());
    } else {
      matrix.reverse();
    }
  }

  let lastGhostY = 0;
  function draw() {
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    drawGrid();
    drawMatrix(arena, {x:0, y:0});

    if (gameState === "playing") {
      // Ghost Piece (Fantôme)
      const ghost = {
        matrix: player.matrix,
        pos: {x: player.pos.x, y: player.pos.y}
      };
      while(!collide(arena, ghost)) {
        ghost.pos.y++;
      }
      ghost.pos.y--;
      
      ctx.globalAlpha = 0.2;
      drawMatrix(ghost.matrix, ghost.pos, ctx, TILE, false); // Pas d'outline sur le fantome
      ctx.globalAlpha = 1;

      drawMatrix(player.matrix, player.pos, ctx, TILE, true);
    }
  }

  function update(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;

    if (gameState === "playing") {
      dropCounter += deltaTime;
      if (dropCounter > dropInterval) {
        playerDrop();
      }
    }

    draw();
    if (gameState !== "gameover") { // On continue de dessiner sauf si gameover (qui a sa propre anim)
        requestAnimationFrame(update);
    }
  }

  /* --- GAME OVER & SCORES --- */

  function loadHighScores() {
    try { return JSON.parse(localStorage.getItem("tetris_scores") || "[]"); } catch { return []; }
  }
  function saveHighScores(list) {
    localStorage.setItem("tetris_scores", JSON.stringify(list));
  }
  function refreshHighScoreList() {
    const scores = loadHighScores();
    highscoreList.innerHTML = "";
    scores.forEach(s => {
      const li = document.createElement("li");
      li.textContent = `${s.name} : ${s.score}`;
      highscoreList.appendChild(li);
    });
  }

  function addHighScore(score) {
    setTimeout(() => {
        let name = prompt("GAME OVER ! \nScore: " + score + "\nTon pseudo :", "Etudiant CIEL");
        if (!name) return;
        name = name.trim().substring(0, 10);

        const scores = loadHighScores();
        scores.push({name, score});
        scores.sort((a,b)=>b.score-a.score);
        if (scores.length > 5) scores.length = 5; // Garder le top 5
        saveHighScores(scores);
        refreshHighScoreList();
    }, 100); // Petit délai pour laisser le navigateur respirer
  }

  function handleGameOver() {
    gameState = "animating";
    sGameOver();
    messageCenter.textContent = "GAME OVER";

    // Animation Rideau Gris
    let y = ROWS - 1;
    const animInterval = setInterval(() => {
        if (y < 0) {
            clearInterval(animInterval);
            addHighScore(player.score);
            gameState = "gameover";
            messageCenter.textContent = "GAME OVER — APPUYEZ SUR ESPACE";
            return;
        }
        // Remplir la ligne de gris (code 99)
        arena[y].fill(99);
        draw(); // Forcer le dessin
        y--;
    }, 40);
  }

  function resetGame() {
    arena.forEach(row => row.fill(0));
    player.score = 0;
    player.level = 1;
    dropInterval = BASE_DROP;
    updateScore();
    nextPieceMatrix = null;
    playerReset();
    dropCounter = 0;
    gameState = "playing";
    messageCenter.textContent = "";
    sStart();
    requestAnimationFrame(update);
  }

  /* --- INPUTS (CLAVIER & MOBILE) --- */

  document.addEventListener("keydown", event => {
    if (!audioCtx) initAudioContext();

    if (event.code === "Space" && (gameState === "waiting" || gameState === "gameover")) {
        resetGame();
        return;
    }

    if (gameState === "playing") {
      switch(event.code) {
        case "ArrowLeft": 
        case "KeyQ": // Support AZERTY
          player.pos.x--;
          if (collide(arena, player)) player.pos.x++; else sMove();
          break;
        case "ArrowRight": 
        case "KeyD":
          player.pos.x++;
          if (collide(arena, player)) player.pos.x--; else sMove();
          break;
        case "ArrowDown": 
        case "KeyS":
          playerDrop();
          break;
        case "ArrowUp": 
        case "KeyZ": // Optionnel : rotation ou drop ? ici HardDrop
           hardDrop();
           break;
        case "Space":
          playerRotate(1);
          break;
        case "KeyP":
          gameState = "paused";
          messageCenter.textContent = "PAUSE";
          break;
      }
    } else if (gameState === "paused" && event.code === "KeyP") {
        gameState = "playing";
        messageCenter.textContent = "";
    }
  });

  // Gestion Mobile (Click handlers)
  const setupMobileBtn = (id, action) => {
    const btn = document.getElementById(id);
    // Eviter le double déclenchement (touch + click)
    btn.addEventListener("touchstart", (e) => { e.preventDefault(); if(!audioCtx) initAudioContext(); action(); });
    btn.addEventListener("click", (e) => { if(!audioCtx) initAudioContext(); action(); });
  };

  setupMobileBtn("btn-left", () => { 
      if(gameState!=="playing") return; 
      player.pos.x--; 
      if(collide(arena, player)) player.pos.x++; 
      else sMove(); 
      draw(); 
  });
  setupMobileBtn("btn-right", () => { 
      if(gameState!=="playing") return; 
      player.pos.x++; 
      if(collide(arena, player)) player.pos.x--; 
      else sMove(); 
      draw(); 
  });
  setupMobileBtn("btn-down", () => { if(gameState==="playing") playerDrop(); draw(); });
  setupMobileBtn("btn-rotate", () => { if(gameState==="playing") playerRotate(1); draw(); });
  setupMobileBtn("btn-drop", () => { if(gameState==="playing") hardDrop(); draw(); });

  // Boutons UI
  startBtn.addEventListener("click", () => { if(!audioCtx) initAudioContext(); resetGame(); });
  muteBtn.addEventListener("click", () => {
      muted = !muted;
      muteBtn.textContent = muted ? "Son : OFF" : "Son : ON";
      if(!muted && !audioCtx) initAudioContext();
  });

  // Démarrage initial
  refreshHighScoreList();
  draw(); // Dessin statique avant le début

</script>
</body>
</html>