<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Tetris BTS CIEL</title>

<style>
  html, body {
    height: 100%;
    margin: 0;
  }

  body {
    background: url("fond_lycee.jpg") no-repeat center center fixed;
    background-size: cover;
    color: #000;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 10px;
    box-sizing: border-box;
  }

  /* Conteneur principal blanc semi-transparent */
  #main {
    background: rgba(255,255,255,0.90);
    border-radius: 16px;
    padding: 15px 25px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    box-sizing: border-box;
  }

  /* Logo */
  #logo {
    width: 120px;
    height: auto;
  }

  /* Titre */
  #title {
    font-size: 32px;
    font-weight: 900;
    margin-top: 5px;
    text-align: center;
    color: #222;
  }

  #subtitle {
    font-size: 14px;
    margin-bottom: 5px;
    color: #444;
    font-weight: 600;
    text-align: center;
  }

  #game-container {
    display: flex;
    gap: 20px;
    align-items: flex-start;
  }

  canvas {
    border: 3px solid #000;
    background: #fff;
    display: block;
    transition: box-shadow 0.15s ease; /* halo doux sur ligne */
  }

  #side-panel {
    display: flex;
    flex-direction: column;
    gap: 10px;
    background: rgba(255,255,255,0.9);
    padding: 10px;
    border-radius: 10px;
    min-width: 190px;
    border: 2px solid #000;
    box-sizing: border-box;
  }

  #score, #level {
    font-size: 18px;
    font-weight: bold;
    color: #000;
  }

  #highscore-title {
    font-size: 14px;
    font-weight: bold;
    margin-top: 4px;
  }

  #start-btn, #mute-btn {
    padding: 8px 10px;
    border-radius: 6px;
    border: 2px solid #000;
    background: #fff;
    font-weight: bold;
    font-size: 12px;
    cursor: pointer;
  }

  #start-btn:hover, #mute-btn:hover {
    background: #ddd;
  }

  #controls {
    font-size: 11px;
    line-height: 1.4;
  }

  #message-center {
    font-size: 20px;
    font-weight: 900;
    text-align: center;
    color: #000;
    margin-top: 5px;
    min-height: 24px;
  }
</style>
</head>
<body>

<div id="main">

  <!-- LOGO + TITRE -->
  <img id="logo" src="logo.gif" alt="Logo BTS CIEL">
  <div id="title">TETRIS – BTS CIEL</div>
  <div id="subtitle">Obtiens le meilleur score pour avoir ton diplôme !</div>

  <div id="game-container">

    <!-- Canvas principal (10 x 20, 40px par case => 400 x 800) -->
    <canvas id="tetris" width="400" height="800"></canvas>

    <!-- Panneau latéral -->
    <div id="side-panel">
      <div id="score">Score : 0</div>
      <div id="level">Niveau : 1</div>

      <div id="highscore-title">Meilleurs scores :</div>
      <ul id="highscore-list" style="padding-left:18px; margin-top:2px;"></ul>

      <button id="start-btn">Recommencer</button>
      <button id="mute-btn">Son : ON</button>

      <div id="controls">
        <b>Contrôles :</b><br>
        ◀ / ▶ : déplacement<br>
        ▼ : descente rapide (soft drop)<br>
        ▲ : chute instantanée (hard drop)<br>
        Espace : rotation / démarrage<br>
        P : pause
      </div>
    </div>
  </div>

  <div id="message-center">APPUYEZ SUR LA BARRE D'ESPACE POUR DÉMARRER</div>
</div>

<script>
  /* --------------------------
     CONFIG & VARIABLES
  --------------------------- */

  const canvas = document.getElementById("tetris");
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = true;

  const scoreElem = document.getElementById("score");
  const levelElem = document.getElementById("level");
  const messageCenter = document.getElementById("message-center");
  const startBtn = document.getElementById("start-btn");
  const muteBtn = document.getElementById("mute-btn");
  const highscoreList = document.getElementById("highscore-list");

  const COLS = 10;
  const ROWS = 20;
  const TILE = 40;
  const BASE_DROP = 800;

  // waiting = écran titre
  // playing = partie en cours
  // paused  = pause
  // gameover = écran game over (en attente d'un redémarrage)
  let gameState = "waiting";
  let dropInterval = BASE_DROP;
  let dropCounter = 0;
  let lastTime = 0;

  /* === Audio doux type clic souris/clavier === */
  let muted = false;
  let audioCtx = null;

  function initAudioContext() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) audioCtx = new AC();
    }
  }

  function playSoftClick(pitch = 1, duration = 0.05, volume = 0.08) {
    if (muted || !audioCtx) return;

    const sampleRate = audioCtx.sampleRate;
    const length = Math.floor(sampleRate * duration);

    const buffer = audioCtx.createBuffer(1, length, sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < length; i++) {
      const envelope = Math.pow(1 - i / length, 3);
      data[i] = (Math.random() * 2 - 1) * envelope;
    }

    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    src.playbackRate.value = pitch;

    const gain = audioCtx.createGain();
    gain.gain.value = volume;

    src.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    src.start(now);
    src.stop(now + duration);
  }

  // sons différenciés
  function sStart()     { playSoftClick(1.1, 0.06, 0.07); }
  function sMove()      { playSoftClick(1.0, 0.03, 0.04); }
  function sRotate()    { playSoftClick(1.4, 0.05, 0.06); }
  function sDrop()      { playSoftClick(0.9, 0.04, 0.06); }
  function sLine() {
    playSoftClick(1.3, 0.04, 0.06);
    setTimeout(() => playSoftClick(1.7, 0.04, 0.05), 40);
  }
  function sGameOver()  { playSoftClick(0.7, 0.10, 0.07); }

  /* Images des visages */
  const FACE_COUNT = 10;
  const tileImages = [null];
  for (let i = 1; i <= FACE_COUNT; i++) {
    const img = new Image();
    img.src = "visage" + i + ".jpg";
    tileImages[i] = img;
  }

  function createMatrix(w, h) {
    const m = [];
    for (let y = 0; y < h; y++) m.push(new Array(w).fill(0));
    return m;
  }

  function createPiece(type) {
    switch (type) {
      case 'T': return [[0,1,0],[1,1,1],[0,0,0]];
      case 'O': return [[1,1],[1,1]];
      case 'L': return [[1,0,0],[1,0,0],[1,1,0]];
      case 'J': return [[0,0,1],[0,0,1],[0,1,1]];
      case 'I': return [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]];
      case 'S': return [[0,1,1],[1,1,0],[0,0,0]];
      case 'Z': return [[1,1,0],[0,1,1],[0,0,0]];
    }
  }

  function drawGrid() {
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 1;
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath();
      ctx.moveTo(x*TILE + .5, .5);
      ctx.lineTo(x*TILE + .5, ROWS*TILE + .5);
      ctx.stroke();
    }
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath();
      ctx.moveTo(.5, y*TILE+.5);
      ctx.lineTo(COLS*TILE+.5, y*TILE+.5);
      ctx.stroke();
    }
  }

  function drawMatrix(matrix, offset, outline=false) {
    matrix.forEach((row,y) => {
      row.forEach((value,x) => {
        if (value !== 0) {
          const px = (x+offset.x)*TILE;
          const py = (y+offset.y)*TILE;
          const img = tileImages[value];
          if (img && img.complete)
            ctx.drawImage(img, px, py, TILE, TILE);
          else {
            ctx.fillStyle="#aaa";
            ctx.fillRect(px,py,TILE,TILE);
          }
        }
      });
    });

    if (!outline) return;

    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2;

    matrix.forEach((row,y) => {
      row.forEach((value,x) => {
        if (value !== 0) {
          const px = (x+offset.x)*TILE;
          const py = (y+offset.y)*TILE;
          ctx.strokeRect(px+0.5, py+0.5, TILE-1, TILE-1);
        }
      });
    });
  }

  /* Arena & player */
  let arena = createMatrix(COLS, ROWS);

  const player = {
    pos: {x:0, y:0},
    matrix: null,
    score: 0,
    level: 1,
  };

  function merge(arena, playerObj) {
    playerObj.matrix.forEach((row,y) => {
      row.forEach((value,x) => {
        if (value !== 0)
          arena[y+playerObj.pos.y][x+playerObj.pos.x] = value;
      });
    });
  }

  function collide(arena, playerObj) {
    const m = playerObj.matrix;
    const o = playerObj.pos;
    for (let y=0; y<m.length; y++) {
      for (let x=0; x<m[y].length; x++) {
        if (m[y][x] !==0 &&
           (arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0)
          return true;
      }
    }
    return false;
  }

  /* Ghost piece */
  function getGhost() {
    if (!player.matrix) return null;
    const ghost = {
      matrix: player.matrix,
      pos: {x: player.pos.x, y: player.pos.y}
    };
    while (!collide(arena, ghost)) {
      ghost.pos.y++;
    }
    ghost.pos.y--;
    return ghost;
  }

  function arenaSweep() {
    let lines = 0;
    for (let y=arena.length-1; y>=0; y--) {
      if (arena[y].every(v => v !== 0)) {
        lines++;
        arena.splice(y,1);
        arena.unshift(new Array(COLS).fill(0));
        y++;
      }
    }
    if (lines > 0) {
      sLine();
      player.score += lines*100;
      if (player.score > player.level*700) {
        player.level++;
        dropInterval = Math.max(150, dropInterval - 70);
      }
      softHighlightBoard();
      updateScore();
    }
  }

  // Effet "soft" : halo vert autour du canvas
  function softHighlightBoard() {
    canvas.style.boxShadow = "0 0 18px rgba(0,200,0,0.8)";
    setTimeout(() => {
      canvas.style.boxShadow = "none";
    }, 150);
  }

  function updateScore() {
    scoreElem.textContent = "Score : " + player.score;
    levelElem.textContent = "Niveau : " + player.level;
  }

  function resetGameState() {
    arena = createMatrix(COLS,ROWS);
    player.score = 0;
    player.level = 1;
    dropInterval = BASE_DROP;
    player.matrix = null;
    player.pos.x = 0;
    player.pos.y = 0;
    dropCounter = 0;
    updateScore();
  }

  function playerReset() {
    const pieces = 'ILJOTSZ';
    const type = pieces[Math.random()*pieces.length|0];

    let shape = createPiece(type);
    const tileId = 1 + (Math.random()*FACE_COUNT|0);
    shape = shape.map(r => r.map(v => v ? tileId : 0));

    player.matrix = shape;
    player.pos.y = 0;
    player.pos.x = (COLS/2|0) - (player.matrix[0].length/2|0);

    if (collide(arena, player)) {
      handleGameOver();
    }
  }

  function playerDrop() {
    player.pos.y++;
    if (collide(arena,player)) {
      player.pos.y--;
      merge(arena,player);
      arenaSweep();
      playerReset();
      sDrop();
    }
    dropCounter = 0;
  }

  function hardDrop() {
    let dist = 0;
    while (!collide(arena,player)) {
      player.pos.y++;
      dist++;
    }
    player.pos.y--;
    dist--;
    playerDrop();
    player.score += Math.max(0, dist*2);
    updateScore();
  }

  function rotate(matrix,dir) {
    for (let y=0; y<matrix.length; y++){
      for (let x=0; x<y; x++){
        [matrix[x][y], matrix[y][x]] =
          [matrix[y][x], matrix[x][y]];
      }
    }
    if (dir>0)
      matrix.forEach(row=>row.reverse());
    else
      matrix.reverse();
  }

  function playerRotate(dir) {
    const pos = player.pos.x;
    let offset=1;
    rotate(player.matrix,dir);
    while(collide(arena,player)) {
      player.pos.x += offset;
      offset = -(offset+(offset>0?1:-1));
      if (offset > player.matrix[0].length) {
        rotate(player.matrix,-dir);
        player.pos.x = pos;
        return;
      }
    }
    sRotate();
  }

  function draw() {
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawGrid();
    drawMatrix(arena,{x:0,y:0});

    if (gameState==="playing" && player.matrix) {
      const ghost = getGhost();
      if (ghost) {
        ctx.globalAlpha = 0.25;
        drawMatrix(ghost.matrix, ghost.pos);
        ctx.globalAlpha = 1;
      }
      drawMatrix(player.matrix, player.pos, true);
    }
  }

  function update(time=0) {
    const delta = time - lastTime;
    lastTime = time;

    if (gameState==="playing") {
      dropCounter += delta;
      if (dropCounter > dropInterval)
        playerDrop();
    }

    draw();
    requestAnimationFrame(update);
  }

  /* HIGH SCORES */
  function loadHighScores() {
    try {
      return JSON.parse(localStorage.getItem("tetris_scores") || "[]");
    } catch {
      return [];
    }
  }

  function saveHighScores(list) {
    localStorage.setItem("tetris_scores", JSON.stringify(list));
  }

  function refreshHighScoreList() {
    const scores = loadHighScores();
    highscoreList.innerHTML = "";
    scores.forEach(s => {
      const li = document.createElement("li");
      li.textContent = s.name + " - " + s.score;
      highscoreList.appendChild(li);
    });
  }

  function addHighScore(score) {
    let name = prompt("GAME OVER\nEntrez votre pseudo :", "Joueur");
    if (!name) return;
    name = name.trim().substring(0, 12);

    const scores = loadHighScores();
    scores.push({name, score});
    scores.sort((a,b)=>b.score-a.score);
    if (scores.length > 10) scores.length = 10;
    saveHighScores(scores);
  }

  refreshHighScoreList();

  function handleGameOver() {
    sGameOver();
    addHighScore(player.score);
    refreshHighScoreList();
    gameState = "gameover";
    messageCenter.textContent = "GAME OVER — APPUYEZ SUR ESPACE POUR REJOUER";
  }

  function startGame() {
    if (!audioCtx) initAudioContext();
    resetGameState();
    playerReset();
    dropCounter = 0;
    gameState = "playing";
    messageCenter.textContent = "";
    sStart();
  }

  /* CONTROLES CLAVIER */
  document.addEventListener("keydown", e=>{
    // Init audio au premier input
    if (!audioCtx) initAudioContext();

    // Démarrage / redémarrage avec ESPACE
    if (e.code === "Space" && (gameState === "waiting" || gameState === "gameover")) {
      e.preventDefault();
      startGame();
      return;
    }

    if (gameState==="playing") {
      if (e.code==="ArrowLeft") {
        e.preventDefault();
        player.pos.x--;
        if (collide(arena,player)) player.pos.x++;
        else sMove();
      } else if (e.code==="ArrowRight") {
        e.preventDefault();
        player.pos.x++;
        if (collide(arena,player)) player.pos.x--;
        else sMove();
      } else if (e.code==="ArrowDown") {
        e.preventDefault();
        playerDrop();
      } else if (e.code==="ArrowUp") {
        e.preventDefault();
        hardDrop();
      } else if (e.code==="Space") {
        e.preventDefault();
        playerRotate(1);
      } else if (e.code==="KeyP") {
        e.preventDefault();
        gameState="paused";
        messageCenter.textContent="PAUSE";
      }
    } else if (gameState==="paused" && e.code==="KeyP") {
      e.preventDefault();
      gameState="playing";
      messageCenter.textContent="";
    }
  });

  /* BOUTONS */
  startBtn.addEventListener("click", ()=>{
    startGame(); // le bouton lance directement une nouvelle partie
  });

  muteBtn.addEventListener("click", ()=>{
    muted = !muted;
    muteBtn.textContent = muted ? "Son : OFF" : "Son : ON";
  });

  // Écran d'attente initial
  messageCenter.textContent = "APPUYEZ SUR LA BARRE D'ESPACE POUR DÉMARRER";
  update();
</script>

</body>
</html>
