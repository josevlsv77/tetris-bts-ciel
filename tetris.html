<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Tetris BTS CIEL - Lycée Simone Veil</title>

<style>
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
  }

  body {
    background: url("fond_lycee.jpg") no-repeat center center fixed;
    background-color: #2c3e50; 
    background-size: cover;
    color: #000;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
  }

  #main {
    background: rgba(255,255,255,0.92);
    border-radius: 16px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    box-sizing: border-box;
    box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    width: 98%;
    height: 98%;
    max-width: 1000px;
    justify-content: center; 
    position: relative;
    z-index: 1;
  }

  #header-group {
    text-align: center;
    margin-bottom: 5px;
  }

  #logo {
    width: 60px;
    height: auto;
    display: block;
    margin: 0 auto;
  }

  #title {
    font-size: 20px;
    font-weight: 900;
    color: #222;
    margin: 0;
  }

  #subtitle {
    font-size: 11px;
    color: #555;
    font-weight: 600;
  }

  #game-container {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    justify-content: center;
    height: 80vh; 
    width: 100%;
  }

  canvas#tetris {
    border: 3px solid #333;
    background: #fff;
    display: block;
    box-shadow: 5px 5px 15px rgba(0,0,0,0.2);
    height: 100%; 
    width: auto; 
    aspect-ratio: 1/2;
  }

  #side-panel {
    display: flex;
    flex-direction: column;
    gap: 8px;
    background: rgba(255,255,255,0.6);
    padding: 15px;
    border-radius: 10px;
    min-width: 180px;
    border: 2px solid #333;
    box-sizing: border-box;
    height: 100%;
    justify-content: center;
  }

  #next-piece-container {
    text-align: center;
    margin-bottom: 10px;
  }
  canvas#next {
    background: #fff;
    border: 2px solid #555;
    margin-top: 2px;
    width: 80px; 
    height: 80px;
  }

  #score-box, #level-box {
    text-align: center;
    margin-bottom: 5px;
  }

  .label-text {
    font-size: 12px;
    text-transform: uppercase;
    color: #555;
    font-weight: bold;
  }

  #score {
    font-size: 20px;
    font-weight: 900;
    color: #000;
  }

  #level {
    font-size: 18px;
    font-weight: bold;
    color: #000;
  }
   
  #rank-name {
    font-size: 14px;
    font-weight: 900;
    color: #d32f2f;
    margin-top: 2px;
    min-height: 20px;
  }

  #highscore-title {
    font-size: 14px;
    font-weight: bold;
    margin-top: 10px;
    text-decoration: underline;
  }

  #highscore-list {
    padding-left: 18px; 
    margin: 5px 0; 
    font-size: 13px;
    max-height: 150px;
    overflow-y: auto;
  }

  button {
    padding: 12px;
    border-radius: 6px;
    border: 2px solid #333;
    background: #fff;
    font-weight: bold;
    font-size: 13px;
    cursor: pointer;
    transition: background 0.2s;
    margin-top: 5px;
  }
  button:hover { background: #eee; }
  button:active { background: #ccc; }
  button:focus { outline: none; }

  #controls-info {
    font-size: 11px;
    line-height: 1.4;
    margin-top: 15px;
    color: #444;
    background: rgba(0,0,0,0.05);
    padding: 5px;
    border-radius: 4px;
  }

  #message-center {
    font-size: 18px;
    font-weight: 900;
    text-align: center;
    color: #d32f2f;
    min-height: 24px;
    margin-top: 5px;
  }

  /* --- CONTRÔLES MOBILE --- */
  #mobile-controls {
    display: none;
    width: 100%;
    justify-content: space-between;
    margin-top: 5px;
    gap: 10px;
    padding-bottom: 5px;
  }
    
  .pad-group {
    display: flex;
    gap: 15px;
  }

  .mob-btn {
    width: 55px;
    height: 55px;
    font-size: 24px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(255,255,255,0.9);
    border: 2px solid #333;
    border-radius: 50%;
    box-shadow: 0 4px 0 #333;
    touch-action: manipulation;
    user-select: none;
  }
  .mob-btn:active {
    transform: translateY(4px);
    box-shadow: none;
    background: #ddd;
  }
  .mob-btn.big {
    width: 65px;
    height: 65px;
    background: #ffeba7;
  }

  /* --- PROVISEUR + BULLE BD (VERSION PC : DROITE) --- */
  #proviseur-box {
    position: absolute;
    left: calc(50% + 400px); 
    bottom: 10px;
    display: none;
    cursor: pointer;
    z-index: 10;
  }

  #proviseur-img {
    height: auto;
    max-height: 50vh;
  }

  #speech-bubble {
    position: absolute;
    left: 100%;
    bottom: 65%;
    margin-left: 12px;
    max-width: 320px;
    background: #fff;
    border-radius: 18px;
    border: 3px solid #333;
    padding: 10px 14px;
    font-size: 14px;
    font-weight: 700;
    color: #111;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
  }

  /* Flèche bulle PC */
  #speech-bubble::after {
    content: ""; position: absolute; right: 100%; bottom: 20%;
    border-width: 10px; border-style: solid;
    border-color: transparent #333 transparent transparent;
  }
  #speech-bubble::before {
    content: ""; position: absolute; right: 100%; bottom: 20%;
    margin-right: -2px; border-width: 9px; border-style: solid;
    border-color: transparent #fff transparent transparent;
  }

  @media (max-width: 800px) {
    #main { 
        width: 100%; height: 100%; padding: 5px; border-radius: 0; justify-content: space-between;
    }
    #header-group { display: none; }
    #game-container { height: 60vh; align-items: center; }
    #side-panel { display: none; } 
    #mobile-header { 
        display: flex; flex-direction: column; align-items: center; width: 95%; 
        font-weight: bold; font-size: 14px; margin-top: 5px;
        background: rgba(255,255,255,0.8); padding: 5px; border-radius: 8px;
    }
    #mobile-header-row { display: flex; justify-content: space-between; width: 100%; }
    #mob-rank { color: #d32f2f; font-size: 12px; margin-top: 2px; font-weight: 900;}

    #mobile-controls { 
      display: flex; 
      padding: 0 15px 15px 15px; 
      box-sizing: border-box;
    }
    #message-center { font-size: 14px; margin-bottom: 5px; }

    /* --- PROVISEUR MOBILE : EN BAS À DROITE --- */
    #proviseur-box {
      left: auto;
      right: 5px;
      bottom: 85px; /* Juste au dessus des boutons contrôles */
      top: auto;
      z-index: 20;
    }
    #proviseur-img {
      height: 120px; /* Plus petit sur mobile pour pas gêner */
      max-height: 20vh;
    }
    
    #speech-bubble {
      max-width: 200px;
      font-size: 12px;
      
      /* Positionnement : à gauche de la tête */
      left: auto;
      right: 100%; 
      bottom: 20%;
      
      margin-left: 0;
      margin-right: 10px;
      white-space: normal;
    }

    /* Flèche bulle Mobile (pointe vers la droite) */
    #speech-bubble::after {
      left: 100%; right: auto; bottom: 20%;
      border-color: transparent transparent transparent #333;
    }
    #speech-bubble::before {
      left: 100%; right: auto; bottom: 20%;
      margin-right: 0; margin-left: -2px;
      border-color: transparent transparent transparent #fff;
    }
  }
   
  @media (min-width: 801px) {
    #mobile-header { display: none; }
  }

</style>
</head>
<body>

<div id="main">

  <div id="header-group">
    <img id="logo" src="Logo.gif" alt="Logo BTS" onerror="this.style.display='none'">
    <div id="title">TETRIS – BTS CIEL</div>
    <div id="subtitle">Lycée Simone Veil - Noisiel</div>
  </div>

  <div id="mobile-header">
    <div id="mobile-header-row">
        <span id="mob-score">Score: 0</span>
        <span id="mob-level">Niv: 1</span>
    </div>
    <div id="mob-rank">Nouvelle Recrue</div>
  </div>

  <div id="game-container">
    <canvas id="tetris" width="800" height="1600"></canvas>

    <div id="side-panel">
      <div id="next-piece-container">
        <div style="font-weight:bold; margin-bottom:5px;">Suivante :</div>
        <canvas id="next" width="160" height="160"></canvas>
      </div>

      <div id="score-box">
        <div class="label-text">Score</div>
        <div id="score">0</div>
      </div>

      <div id="level-box">
        <div class="label-text">Niveau</div>
        <div id="level">1</div>
        <div id="rank-name">Nouvelle Recrue</div>
      </div>

      <div id="highscore-title">Meilleurs scores :</div>
      <ul id="highscore-list"></ul>

      <button id="start-btn">Recommencer</button>
      <button id="mute-btn">Son : ON</button>

      <div id="controls-info">
        <b>Contrôles :</b><br>
        ◀/▶/▼ : Bouger<br>
        ▲ : Hard Drop<br>
        Espace : Rotation<br>
        P : Pause
      </div>
    </div>
  </div>

  <div id="mobile-controls">
    <div class="pad-group">
      <button class="mob-btn" id="btn-left">◀</button>
      <button class="mob-btn" id="btn-down">▼</button>
      <button class="mob-btn" id="btn-right">▶</button>
    </div>
    <div class="pad-group">
      <button class="mob-btn big" id="btn-rotate">↻</button>
      <button class="mob-btn big" id="btn-drop">⤓</button>
    </div>
  </div>

  <div id="message-center">APPUYEZ SUR ESPACE POUR DÉMARRER</div>
</div>

<div id="proviseur-box">
  <img id="proviseur-img" src="proviseur.png" alt="Proviseur du lycée">
  <div id="speech-bubble"></div>
</div>

<script>
  /* --- INITIALISATION --- */
  const canvas = document.getElementById("tetris");
  const ctx = canvas.getContext("2d");
  const nextCanvas = document.getElementById("next");
  const nextCtx = nextCanvas.getContext("2d");
    
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  nextCtx.imageSmoothingEnabled = true;
  nextCtx.imageSmoothingQuality = 'high';

  const scoreElem = document.getElementById("score");
  const levelElem = document.getElementById("level");
  const rankElem = document.getElementById("rank-name");

  const mobScoreElem = document.getElementById("mob-score");
  const mobLevelElem = document.getElementById("mob-level");
  const mobRankElem = document.getElementById("mob-rank");

  const messageCenter = document.getElementById("message-center");
  const startBtn = document.getElementById("start-btn");
  const muteBtn = document.getElementById("mute-btn");
  const highscoreList = document.getElementById("highscore-list");

  /* --- PROVISEUR --- */
  const proviseurBox = document.getElementById("proviseur-box");
  const speechBubble = document.getElementById("speech-bubble");
  let proviseurTimeout = null;

  // CLIC POUR FERMER LE PROVISEUR
  proviseurBox.addEventListener("click", () => {
      proviseurBox.style.display = "none";
  });
  proviseurBox.addEventListener("touchstart", (e) => {
      e.preventDefault();
      proviseurBox.style.display = "none";
  });

  const proviseurDialogues = {
    start: [
      "« Bienvenue en BTS CIEL… essayez de faire mieux que vos bulletins. »",
      "« On s’échauffe : comme à la rentrée, mais avec moins de paperasse. »",
      "« Tetris CIEL : si vous ragez déjà, attendez l’E4. »"
    ],
    line: [
      "« Voilà, une ligne propre. Si seulement vos copies étaient aussi alignées. »",
      "« Pas mal. Continuez comme ça et je signe la mention. »",
      "« Une ligne en moins, un neurone en plus : bon calcul. »",
      "« C’est ce que j’appelle de la gestion de stock efficace. »"
    ],
    level: [
      "« Changement de niveau : comme le passage en 2e année, mais sans rattrapage. »",
      "« Vous venez de monter d’un cran. Gardez ce rythme au conseil de classe. »",
      "« Nouveau niveau. On va voir si vous tenez la cadence. »"
    ],
    gameover: [
      "« GAME OVER… mais au lycée, on n’a pas de bouton Recommencer. »",
      "« Conseil du proviseur : révisez la stratégie avant la prochaine partie. »",
      "« Ça, c’est ce qu’on appelle une commission d’appel ratée. »"
    ],
    generic: [
      "« Les CIEL, pensez à sauvegarder… vos neurones. »",
      "« Un Tetris bien rangé, c’est comme une bonne salle machine : ça respire. »",
      "« Pause ? Après avoir battu le highscore, pas avant. »",
      "« Vous jouez, mais n’oubliez pas que les notes, elles, sont bien réelles. »"
    ]
  };

  function getProviseurText(reason) {
    const pool = proviseurDialogues[reason] || proviseurDialogues.generic;
    return pool[Math.floor(Math.random() * pool.length)];
  }

  function showProviseur(reason) {
    const text = getProviseurText(reason);
    speechBubble.textContent = text;
    proviseurBox.style.display = "block";
    if (proviseurTimeout) clearTimeout(proviseurTimeout);
    proviseurTimeout = setTimeout(() => {
      proviseurBox.style.display = "none";
    }, 4500);
  }

  // Constantes Jeu
  const COLS = 10;
  const ROWS = 20;
  const TILE = 80; 
  const NEXT_TILE = 40; 
  const BASE_DROP = 800;

  let gameState = "waiting"; 
  let dropInterval = BASE_DROP;
  let dropCounter = 0;
  let lastTime = 0;
  let nextPieceMatrix = null; 

  let muted = false;
  let audioCtx = null;

  // Récupération préférence sonore
  if(localStorage.getItem("tetris_muted") === "true") {
      muted = true;
      muteBtn.textContent = "Son : OFF";
  }

  const cielRanks = [
      "Nouvelle Recrue",
      "Apprenti Câbleur",
      "Scripteur Bash",
      "Décodeur Binaire",
      "Admin Réseau",
      "Développeur C++",
      "Survivant de l'E4",
      "Expert Cybersécu",
      "Chef de Projet E6",
      "Major de Promo",
      "Diplômé CIEL",
      "Légende de Simone Veil"
  ];

  function getRankName(level) {
      if (level > cielRanks.length) return cielRanks[cielRanks.length - 1];
      return cielRanks[level - 1];
  }

  /* --- AUDIO --- */
  function initAudioContext() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) audioCtx = new AC();
    }
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }

  function playTone(freq, type, duration, vol) {
    if (muted || !audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  }

  function sStart()  { playTone(440, 'triangle', 0.5, 0.1); setTimeout(()=>playTone(880, 'triangle', 0.5, 0.1), 100); }
  function sMove()   { playTone(200, 'sine', 0.1, 0.05); }
  function sRotate() { playTone(300, 'square', 0.1, 0.05); }
  function sDrop()   { playTone(100, 'sawtooth', 0.2, 0.08); }
  function sLine()   { playTone(600, 'sine', 0.2, 0.1); setTimeout(()=>playTone(1200, 'sine', 0.4, 0.1), 100); }
  function sGameOver(){ playTone(150, 'sawtooth', 1.0, 0.2); setTimeout(()=>playTone(100, 'sawtooth', 1.0, 0.2), 300); }

  // ----- VISAGES -----
  const FACE_COUNT = 11; 
  const tileImages = [null];
  for (let i = 1; i <= FACE_COUNT; i++) {
    const img = new Image();
    img.src = "visage" + i + ".jpg";
    tileImages[i] = img;
  }

  const colors = [
    null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF', '#555555'
  ];

  /* --- LOGIQUE --- */
  function createMatrix(w, h) {
    const m = [];
    for (let y = 0; y < h; y++) m.push(new Array(w).fill(0));
    return m;
  }

  function createPiece(type) {
    const id = 1 + (Math.random() * FACE_COUNT | 0);

    switch (type) {
      case 'T': return [[0, id, 0],
                        [id, id, id],
                        [0,  0,  0]];
      case 'O': return [[id, id],
                        [id, id]];
      case 'L': return [[0,  0,  id],
                        [id, id, id],
                        [0,  0,  0]]; 
      case 'J': return [[id, 0,  0],
                        [id, id, id],
                        [0,  0,  0]];
      case 'I': return [[0,  id, 0,  0],
                        [0,  id, 0,  0],
                        [0,  id, 0,  0],
                        [0,  id, 0,  0]];
      case 'S': return [[0,  id, id],
                        [id, id, 0],
                        [0,  0,  0]];
      case 'Z': return [[id, id, 0],
                        [0,  id, id],
                        [0,  0,  0]];
    }
    return [[id]];
  }

  let arena = createMatrix(COLS, ROWS);

  const player = {
    pos: {x:0, y:0},
    matrix: null,
    score: 0,
    level: 1,
  };

  let flashPhase = 0; // Sert à l'animation de suppression

  // --- NOUVEAU : Grille plus fine ---
  function drawGrid() {
    ctx.strokeStyle = "rgba(0, 0, 0, 0.05)"; // Gris très fin
    ctx.lineWidth = 1; 
    
    for (let x = 1; x < COLS; x++) {
      ctx.beginPath(); ctx.moveTo(x*TILE, 0); ctx.lineTo(x*TILE, ROWS*TILE); ctx.stroke();
    }
    for (let y = 1; y < ROWS; y++) {
      ctx.beginPath(); ctx.moveTo(0, y*TILE); ctx.lineTo(COLS*TILE, y*TILE); ctx.stroke();
    }
  }

  // --- NOUVEAU : Dessin "Pro" avec animation Data Purge ---
  function drawMatrix(matrix, offset, context = ctx, tileSize = TILE) {
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          const px = (x + offset.x) * tileSize;
          const py = (y + offset.y) * tileSize;

          // Animation suppression (99)
          if (value === 99) {
            // flashPhase va de 1 à 10
            const progress = flashPhase / 10; 
            const scale = 1 - progress; // De 1 à 0

            const centerX = px + tileSize / 2;
            const centerY = py + tileSize / 2;
            const size = tileSize * scale;
            const offsetSize = size / 2;

            // Fond blanc éclatant
            context.fillStyle = `rgba(255, 255, 255, ${1 - progress})`; 
            context.fillRect(px, py, tileSize, tileSize);

            // Le bloc qui rétrécit
            context.save();
            context.translate(centerX, centerY);
            
            // Carré couleur CIEL par défaut pour l'anim
            context.fillStyle = "#0DC2FF"; 
            context.fillRect(-offsetSize, -offsetSize, size, size);
            
            // Flash blanc par dessus
            context.fillStyle = `rgba(255, 255, 255, 0.5)`;
            context.fillRect(-offsetSize, -offsetSize, size, size);

            context.restore();
            return;
          }

          // Dessin normal
          const imgIndex = ((value - 1 + FACE_COUNT) % FACE_COUNT) + 1;
          const img = tileImages[imgIndex];

          if (img && img.complete && img.naturalWidth !== 0) {
            context.drawImage(img, px, py, tileSize, tileSize);
            // Reflet glossy
            context.fillStyle = "rgba(255,255,255,0.15)";
            context.fillRect(px, py, tileSize, tileSize/3);
          } else {
            // Fallback
            context.fillStyle = colors[value % colors.length] || 'grey';
            context.fillRect(px, py, tileSize, tileSize);
            context.fillStyle = "rgba(255,255,255,0.3)";
            context.fillRect(px, py, tileSize, 4);
            context.fillStyle = "rgba(0,0,0,0.2)";
            context.fillRect(px, py + tileSize - 4, tileSize, 4);
          }
          
          // Bordure fine
          context.strokeStyle = "rgba(0,0,0,0.1)";
          context.lineWidth = 1;
          context.strokeRect(px, py, tileSize, tileSize);
        }
      });
    });
  }

  function drawNextPiece() {
    if (!nextPieceMatrix) return;
    nextCtx.fillStyle = "#fff";
    nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
    
    const offsetX = (4 - nextPieceMatrix[0].length) / 2;
    const offsetY = (4 - nextPieceMatrix.length) / 2;
    
    drawMatrix(nextPieceMatrix, {x: offsetX, y: offsetY}, nextCtx, NEXT_TILE);
  }

  function merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          arena[y + player.pos.y][x + player.pos.x] = value;
        }
      });
    });
  }

  function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for (let y = 0; y < m.length; ++y) {
      for (let x = 0; x < m[y].length; ++x) {
        if (m[y][x] !== 0 &&
           (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  // --- NOUVEAU : Animation fluide et suppression robuste ---
  function arenaSweep() {
    if (gameState === "lineflash" || gameState === "animating") return;

    const rowsToClear = [];
    for (let y = arena.length - 1; y >= 0; --y) {
      let full = true;
      for (let x = 0; x < arena[y].length; ++x) {
        if (arena[y][x] === 0) { full = false; break; }
      }
      if (full) rowsToClear.push(y);
    }

    if (rowsToClear.length === 0) {
      if (Math.random() < 0.05) showProviseur("generic");
      return;
    }

    gameState = "lineflash";
    rowsToClear.forEach(y => arena[y].fill(99));

    let frame = 0;
    const maxFrames = 10; // Animation sur 10 images

    const flashInterval = setInterval(() => {
      frame++;
      flashPhase = frame; 
      draw(); 

      if (frame >= maxFrames) {
        clearInterval(flashInterval);

        rowsToClear.sort((a, b) => b - a);
        rowsToClear.forEach(y => arena.splice(y, 1));
        while (arena.length < ROWS) arena.unshift(new Array(COLS).fill(0));

        const lines = rowsToClear.length;
        sLine();
        const linePoints = [0, 40, 100, 300, 1200];
        player.score += (linePoints[lines] || 1200) * player.level;

        if (player.score > player.level * 1000) {
          player.level++;
          dropInterval = Math.max(100, 800 - (player.level * 50));
          showProviseur("level");
        } else if (Math.random() < 0.4) {
          showProviseur("line");
        }

        updateScore();
        gameState = "playing";
        draw(); 
      }
    }, 30);
  }

  function updateScore() {
    scoreElem.textContent = player.score;
    levelElem.textContent = player.level;
    
    const currentRank = getRankName(player.level);
    rankElem.textContent = currentRank;

    mobScoreElem.textContent = "Score: " + player.score;
    mobLevelElem.textContent = "Niv: " + player.level;
    mobRankElem.textContent = currentRank;
  }

  function playerReset() {
    const pieces = 'ILJOTSZ';
    if (nextPieceMatrix === null) {
        nextPieceMatrix = createPiece(pieces[pieces.length * Math.random() | 0]);
    }
    player.matrix = nextPieceMatrix;
    nextPieceMatrix = createPiece(pieces[pieces.length * Math.random() | 0]);
    drawNextPiece();

    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

    if (collide(arena, player)) {
      handleGameOver();
    }
  }

  function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      sDrop();
      arenaSweep();
      playerReset();
    }
    dropCounter = 0;
  }

  function hardDrop() {
    while (!collide(arena, player)) {
      player.pos.y++;
    }
    player.pos.y--; 
    merge(arena, player);
    sDrop();
    arenaSweep();
    playerReset();
  }

  function playerRotate(dir) {
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while (collide(arena, player)) {
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if (offset > player.matrix[0].length) {
        rotate(player.matrix, -dir);
        player.pos.x = pos;
        return;
      }
    }
    sRotate();
  }

  function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
      for (let x = 0; x < y; ++x) {
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if (dir > 0) matrix.forEach(row => row.reverse());
    else matrix.reverse();
  }

  // Cette fonction n'est plus utilisée directement car le ghost est dessiné inline
  // mais on la garde pour l'animation de Game Over ou autre
  function drawPieceOutline(matrix, pos) {
    ctx.lineWidth = 4;
    ctx.strokeStyle = "#000";
    ctx.beginPath();
    // (code simplifié si besoin, mais ici le draw() s'occupe de tout)
  }

  function draw() {
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    drawGrid();
    drawMatrix(arena, {x:0, y:0}); 

    if (gameState === "playing" || gameState === "lineflash") {
      const ghost = {
        matrix: player.matrix,
        pos: {x: player.pos.x, y: player.pos.y}
      };
      while (!collide(arena, ghost)) {
        ghost.pos.y++;
      }
      ghost.pos.y--;
      
      // --- NOUVEAU : GHOST STYLE "OUTLINE" ---
      ctx.save();
      ctx.globalAlpha = 0.3; // Transparence légère
      ctx.strokeStyle = "#333"; // Contour gris foncé
      ctx.lineWidth = 2;
      // On dessine manuellement les contours sans remplir
      ghost.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
             ctx.strokeRect((x + ghost.pos.x) * TILE, (y + ghost.pos.y) * TILE, TILE, TILE);
          }
        });
      });
      ctx.restore();

      // DESSIN DU JOUEUR
      drawMatrix(player.matrix, player.pos, ctx, TILE);
      
      // Outline autour de la pièce du joueur
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#000";
      player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
             ctx.strokeRect((x + player.pos.x) * TILE, (y + player.pos.y) * TILE, TILE, TILE);
          }
        });
      });
    }
  }

  function update(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;

    if (gameState === "playing") {
      dropCounter += deltaTime;
      if (dropCounter > dropInterval) {
        playerDrop();
      }
    }

    draw();
    if (gameState !== "gameover") { 
        requestAnimationFrame(update);
    }
  }

  /* --- GAME OVER & SCORES --- */
  function loadHighScores() {
    try { return JSON.parse(localStorage.getItem("tetris_scores") || "[]"); } catch { return []; }
  }
  function saveHighScores(list) {
    localStorage.setItem("tetris_scores", JSON.stringify(list));
  }
  function refreshHighScoreList() {
    const scores = loadHighScores();
    highscoreList.innerHTML = "";
    scores.forEach(s => {
      const li = document.createElement("li");
      li.textContent = `${s.name} : ${s.score}`;
      highscoreList.appendChild(li);
    });
  }

  function addHighScore(score) {
    setTimeout(() => {
        let name = prompt("GAME OVER ! \nGrade atteint : " + getRankName(player.level) + "\nTon pseudo :", "Etudiant CIEL");
        if (!name) return;
        name = name.trim().substring(0, 10);

        const scores = loadHighScores();
        scores.push({name, score});
        scores.sort((a,b)=>b.score-a.score);
        if (scores.length > 5) scores.length = 5; 
        saveHighScores(scores);
        refreshHighScoreList();
    }, 100); 
  }

  function handleGameOver() {
    gameState = "animating";
    sGameOver();
    messageCenter.textContent = "GAME OVER";
    showProviseur("gameover");

    let y = ROWS - 1;
    const animInterval = setInterval(() => {
        if (y < 0) {
            clearInterval(animInterval);
            addHighScore(player.score);
            gameState = "gameover";
            messageCenter.textContent = "GAME OVER — ESPACE POUR REJOUER";
            return;
        }
        arena[y].fill(99);
        flashPhase = 5; // Pour qu'on voit quelque chose
        draw(); 
        y--;
    }, 40);
  }

  function resetGame() {
    arena.forEach(row => row.fill(0));
    player.score = 0;
    player.level = 1;
    dropInterval = BASE_DROP;
    updateScore();
    nextPieceMatrix = null;
    playerReset();
    dropCounter = 0;
    gameState = "playing";
    messageCenter.textContent = "";
    sStart();
    showProviseur("start");
    requestAnimationFrame(update);
  }

  /* --- INPUTS CLAVIER --- */
  document.addEventListener("keydown", event => {
    if (!audioCtx) initAudioContext();

    if (event.code === "Space" && (gameState === "waiting" || gameState === "gameover")) {
        resetGame();
        return;
    }

    if (gameState === "playing") {
      switch(event.code) {
        case "ArrowLeft": 
        case "KeyQ": 
          player.pos.x--;
          if (collide(arena, player)) player.pos.x++; else sMove();
          break;
        case "ArrowRight": 
        case "KeyD":
          player.pos.x++;
          if (collide(arena, player)) player.pos.x--; else sMove();
          break;
        case "ArrowDown": 
        case "KeyS":
          playerDrop();
          break;
        case "ArrowUp": 
        case "KeyZ": 
           hardDrop();
           break;
        case "Space":
          playerRotate(1);
          break;
        case "KeyP":
          gameState = "paused";
          messageCenter.textContent = "PAUSE";
          break;
      }
    } else if (gameState === "paused" && event.code === "KeyP") {
        gameState = "playing";
        messageCenter.textContent = "";
    }
  });

  /* --- CONTRÔLES MOBILE --- */
  const setupMobileBtn = (id, action) => {
    const btn = document.getElementById(id);
    btn.addEventListener("touchstart", (e) => { e.preventDefault(); if(!audioCtx) initAudioContext(); action(); });
    btn.addEventListener("click", (e) => { if(!audioCtx) initAudioContext(); action(); });
  };

  setupMobileBtn("btn-left", () => { if(gameState==="playing") { player.pos.x--; if(collide(arena, player)) player.pos.x++; else sMove(); draw(); }});
  setupMobileBtn("btn-right", () => { if(gameState==="playing") { player.pos.x++; if(collide(arena, player)) player.pos.x--; else sMove(); draw(); }});
  setupMobileBtn("btn-down", () => { if(gameState==="playing") playerDrop(); draw(); });
  setupMobileBtn("btn-rotate", () => { if(gameState==="playing") playerRotate(1); draw(); });
  setupMobileBtn("btn-drop", () => { if(gameState==="playing") hardDrop(); draw(); });

  startBtn.addEventListener("click", () => {
      startBtn.blur();
      if(!audioCtx) initAudioContext();
      resetGame();
  });

  muteBtn.addEventListener("click", () => {
      muteBtn.blur();
      muted = !muted;
      muteBtn.textContent = muted ? "Son : OFF" : "Son : ON";
      localStorage.setItem("tetris_muted", muted); 
      if(!muted && !audioCtx) initAudioContext();
  });

  refreshHighScoreList();
  updateScore();
  draw(); 

  // --- TAP POUR DÉMARRER SUR MOBILE ---
  canvas.addEventListener("touchstart", () => {
      if (!audioCtx) initAudioContext();
      if (gameState === "waiting" || gameState === "gameover") {
          resetGame();
      }
  });

</script>
</body>
</html>